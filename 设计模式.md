---
title: C++版设计模式
date: 2019-08-02 22:28:50
tags:  C++
mathjax: true

---


学习书籍： 《设计模式：可复用面向对象软件的基础》<!--more-->

## 引言

数据库有设计模式，架构有设计模式。而这里介绍的面向对象的设计模式。

面对对象机制:

- 封装，隐藏内部实现
- 继承，复用现有代码
- 多态，改写对象行为

复杂问题处理方法：

- 分解
- 抽象

分解的方法，代码不容易复用。而抽象可以采用一个通用的方法统一处理，所以实现了代码的复用。


## 设计原则

### 重新认识面向对象

- 隔离变化：从宏观层面来看，面向对象的构建方式更能适用软件的变化，能够将变化所带来的影响降为最小
- 各司其责：从微观方面来看，面向对象的方式更强调各个类的“责任”，由于需求变化导致的新增类型不应该影响原来类型的实现——就是所谓的各司其责，一般通过采用多态机制实现。
- 对象是什么
	- 从语言层面来看，对象封装了代码和数据
	- 从规格层面来讲，对象是一系列可被使用的公共接口
	- 从概念层面来讲，对象是某种拥有责任的抽象


### 面向对象设计原则

#### 1.依赖导致原则（DIP）

- 高层模块（稳定）不应该依赖于底层模块（变化），二者都应依赖于抽象（稳定）。
- 抽象（稳定）不应该依赖于实现细节（变化），实现细节应依赖于抽象（稳定）。
	

MainForm是一个高层模块，Line,Rect是一个底层模块，底层模块可能变化，比如添加Circle类等。MainForm类依赖于Line,Rect等，这样是不好的，因为高层模块依赖底层模块。

另一种，MainForm依赖于一个抽象类Shape，而Line, Rect等也依赖于Shape。这样的设计是好的，二者都依赖于抽象，并且实现细节（Rect,Line,Circle等）依赖于抽象。  

依赖导致原则是是最重要的设计原则，贯穿所有设计摸出。

#### 2.开放封闭原则(OCP)

- 对扩展开放，对更改封闭
- 类模板应该可扩展，但是不可修改

比如，有一个桌子不满足消防规定，即材料无法满足一定的防火等级。于是将桌子返回给厂家。第一种厂家，将桌子上不满足防火等级的材料拆掉，并重新制作（修改）；而聪明的厂家会在桌子上刷一层防火物质（扩展）。

#### 3.单一职责原则(SRP)

- 一个类应该仅有一个引起它变化的原因。
- 变化的方向隐含着类的责任。

#### 4.LisKov替换原则(LSP)

- 子类必须能够替换它们的基类(IS-A)。
- 继承表达类型抽象。


#### 5.接口隔离原则(ISP)

- 不应该强迫客户程序依赖它们不用的方法。
- 接口应该小而完备。

#### 6.优先使用对象组合，而不是类继承

- 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。
- 继承在某种程度上破坏了封装性，子类父类耦合度高。
- 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。

备注：耦合度是一种软件度量，是指一程序中，模块及模块之间信息或参数依赖的程度。耦合度越高，代码越差，因为一个模块修改，可能会影响多个模块，这是一种不好的设计。

#### 7.封装变化点

使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。

从底层思维角度来讲，封装就是封装代码和数据，而从更高层次的理解，封装是封装变化点，一层变化，另一侧稳定。
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
#### 8.针对接口编程，而不是针对实现编程

- 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
- 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。
- 减少系统中各部分的依赖关系，从而实现“高内聚，松耦合”的类型设计方案。

### 设计原则提升为设计经验

设计习语： 描述与特定编程语言相关的底层模式，技巧惯用法

设计模式：主要描述的是“类和相互通信的对象之间的组织关系”，包括它们的角色、职责、写作方式等方面。

架构模式： 描述系统中与基本结构组织关系密切的高层模式，包括子系统划分，职责，以及如何组织它们之间关系的规则。

## 设计模式

GOF-23模式分类：

- 从目的来看：
	- 创建型模式：将对象的部分创建工作，从而应对需求变化为对象创建时具体对象类型实现引来的冲击。
	- 结构性模式：通过类继承或者对象组合获得灵活的结构，从而应对需求变化为对象的结构带来的冲击。
	- 行为型模式：通过类继承或对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击。

- 从范围来看：
	- 类模式：处理类与子类的静态关系，偏向于继承方式
	- 对象模式：处理对象间的动态关系，偏向于组合方式

- 功能

	- 组件协作：
		- Template Method 模板方法
		- Strategy 策略模式
		- Observer/Event 观察者/事件模式
	
	
	- 单一职责：
	
	- 对象创建
	
	- 对象性能
	
	- 接口隔离
	
	- 状态变化
	
	- 数据结构
	
	- 行为变化
	
	- 领域问题





重构获得模式：

- 面对对象设计模式是“好的面向对象设计”，所谓“好的面向对象设计”指是那些可以满足“应对变化，提供复用”的设计。
- 现代软件设计的特征是“需求的频繁变化”。设计模式的要点是“寻找变化点，然后在变化点处应用设计模式，从而来更好地应对需要的变化”。“什么时候、什么地方应用设计模式”比“理解设计模式结构本身”更为重要。
- 设计模式的应用不宜先入为主，一上来就使用设计模式是对设计模式的最大误用。没有一步到位的设计模式。敏捷软件开发实践提倡的”Refactoring to Patterns(重构获得模式)“是目前普遍公认的最好的使用设计模式的方法。首先没有应用设计模式的时候，会存在什么问题，然后一步一步迭代修改，应用设计模式。

推荐书籍： 《重构》和 《重构与模式》


重构关键技法：

-  静态 -> 动态
-  早绑定 -> 晚绑定
-  继承  -> 组合
-  编译时依赖 -> 运行时依赖
-  紧耦合 -> 松耦合

## 组件协作模式

现在软件专业分工之后的第一个结果是”框架与应用程序的划分“，”组件协作“模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。

典型模式：

- Template Method 模板方法
- Strategy 策略方式
- Observer/Event 观察者/事件

这三种是典型的组件协作模式，其他模式也有组件协作。

### Tempalte Method(模板方法)

#### 动机

在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。

如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或晚期实现需求？

第一种写法：

	class Library{
	public:
		void Step1(){ //稳定
			//...
		}
		void Step3(){//稳定
			//...
		}
		void Step5(){//稳定
			//...
		}
	};
	
	class Application{
	public:
		bool Step2(){
			//...
		}
		void Step4(){
			//...
		}
	};
	
	int main()
	{
		Library lib();
		Application app();
	
		lib.Step1();
	
		if (app.Step2()){  //支持变化 ==> 虚函数的多态调用
			lib.Step3();
		}
			
		for(int i = 0; i < 4; i++){
			app.Step4();//支持变化 ==> 虚函数的多态调用
		}
	
		lib.Step5();
	};

改善写法(Template Method)：

	class Library{
	public:
		//稳定 template method
		void Run()
		{
			Step1();
	
			if (Step2()){  //支持变化 ==> 虚函数的多态调用
				Step3();
			}
			
			for(int i = 0; i < 4; i++){
				Step4();//支持变化 ==> 虚函数的多态调用
			}
	
			Step5();
		}
		virtual ~Library() {};
	protected:
		void Step1(){ //稳定
			//...
		}
		void Step3(){//稳定
			//...
		}
		void Step5(){//稳定
			//...
		}
		virtual bool Step2() = 0; //变化
		virtual void Step4() = 0; //变化		
	}; 
	
	class Application : public Library{
	protected: 
		virtual bool Step2(){
			//...子类重写实现
		}
		virtual void Step4(){
			//...子类重写实现
		}
	};
	
	int main()
	{
		Library * pLib = new Application();
		lib->run();
	
		delete pLib;
	}

结构化软件设计流程：

![](https://i.imgur.com/kuX3Z1r.png)

第一种写法就是上述流程实现。

Template method写法：

将Applicatoin开发人员所写的程序主流程放到Library中。

第一种是Application（晚）调用Library（早）（早绑定）。第二种是Library（早）调用Appliction（晚）（虚函数调用子类的实现）（晚绑定）。

#### 定义

定义一个操作中的算法的骨架（稳定），而将一些步骤延迟（变化）到子类中。Template Method使得子类可以不改变（复用）一个算法的结构即可重新定义（override重写）该算法的某些特定步骤。

其中的骨架就是run()函数，一些步骤（变化）就是Step2()和Step4()，这些方法在子类中可以重写。子类可以复用run()算法结构。

稳定的代码写成非虚函数，非稳定（变化）的代码写成虚函数（纯虚函数）。

我们假定run()是稳定的，如果run()不稳定，经常变化，就不适用Template method。所有东西都不稳定，所有的模式都没有意义，或者所有东西都稳定，所有模式也都没有意义。设计模式应用在变化与稳定之中，寻找变化点。

C语言时代，程序员经常需要写一个框架（程序主流程），而在C++时代，采用了Template method，这个框架被library开发者已经写好，只需要写几个步骤。

设计结构：

![](https://i.imgur.com/B0F2GPb.png)

其中TemplateMethod()是稳定的，而PrimitiveOperation1()和PrimitiveOperation2()是变化的。

总结：

- Template Method模式是一种非常基础性的设计模式，在面对对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点，是代码复用方法的基本实现结构。
- 除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用你”的反向控制结构是Template Method的典型应用。
- 在具体实现方面，被Template Method调用的虚方法可以有实现，也可以没有任何是咩（抽象方法、纯虚方法），但一般它们设计为protect方法（这些方法单独作为一个方法没有意义，放在一个流程中才有意义）。

实现晚绑定机制的手段：

- 虚函数（虚函数本质也是函数指针实现的）
- 函数指针（C语言时代就有）


### Strategy(策略模式)

#### 动机

- 在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂，而且有时候指支持不使用的算法也是一个性能负担。

- 如何在运行时根据需要透明低更改对象的算法？将算法与对象本身解耦，从而避免上述问题？

场景：计算每个国家的税收。


	enum TaxBase {
		CN_Tax,
		US_Tax,
		DE_Tax,
	};
	
	class SalesOrder {
		TaxBase tax;
	public:
		double CalculateTax() {
			if (tax == CN_Tax) {
				//CN
			}
			else if (tax == US_Tax) {
				//US
			}
			else if (tax == DE_Tax) {
				//DE...
			}
			//...
		}
	};

如果未来需要指出日本，法国的税收计算。就需要修改枚举类型，并对CalculateTax方法修改，这就违反了开发封闭原则。而应该采用扩展的方式，而不是修改。


	class TaxStrategy {
	public:
		virtual double Calculate(const Context& context) = 0;
		virtual ~TaxStrategy() {}
	};
	
	class CNTax : public TaxStrategy {
	public:
		virtual double Calculate(const Context& context) {
			//CN
		}
	};
	
	class USTax : public TaxStrategy {
	public:
		virtual double Calculate(const Context& context) {
			//US
		}
	};
	
	class DETax : public TaxStrategy {
	public:
		virtual double Calculate(const Context& context) {
			//DE
		}
	};
	
	class SalesOrder {
	private:
		TaxStrategy * strategy;
	public:
		SalesOrder(strategyFactory* strategyFactory) {
			this->strategy = strateyFactory;
		}
		~SalesOrder() {
			delete this->strategy;
		}
		double CalculateTax() {
			//...
			Context context;
	
			double val = strategy->Calculate(Context); //多态调用
			//...
		}
	};

对于上述方法，如果需要添加计算法国的税收。只需要添加一个类继承TaxStrategy（扩展）。不需要修改任何内容（得到了复用），这就符合了开放封闭原则。

	class FRTax : public TaxStrategy {
	public:
		virtual double Calculate(const Context& context) {
			//DE
		}
	};

#### 定义

定义一系列算法，把它们一个个封装起来，并且使它们可相互替换（变换）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展，子类化）。

设计结构：

![](https://i.imgur.com/x2mVXC4.png)

红色框内的是稳定的，而蓝色框内的是变化的（可以增加各个国家的税收计算）。

要点总结：

- Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在__运行时__方便地根据需要在各个算法之间进行切换。
- Strategy模式提供了条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通过都需要Strategy。
- 如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。

出现if,else语句，就是使用Strategy模式的特征。不推荐使用ifelse，这是结构化时代的分而治之的思想，而应该采用抽象思维。

当然有时候ifelse无法适用于Strategy，即ifelse绝对不变的情况，比如根据性别来判断，男女是绝对不变的，所以无法使用Strategy；还有就是一周七天，也是固定不变的，就不适用于Strategy。switch跟ifelse相同。


### Observer(观察者模式)

#### 动机

- 在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系”———一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这种的依赖关系过于紧密，将使软件不能很好地抵御变化。
- 使用面向对象计数，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。

场景：将大文件分割成多个小文件。

	class MainForm : public Form
	{
		TextBox * txtFilePath;
		TextBox * txtFileNumber;
	public:
		void Button1_Click() {
			string filePath = txtFilePath->getText();
			int number = atoi(txtFileNumber->getText()).c_str();
	
			FileSplitter splitter(filePath, number);
	
			splitter.split();
		}
	};
	
	class FileSplitter {
		string m_filePath;
		int m_fileNumber;
	public:
		FileSplitter(const string& filePath, int fileNumber) : 
			m_filePath(filePath),m_fileNumber(fileNumber){
		}
	
		void split() {
			//1.读取大文件
			//2. 分批次先小文件中写入
			for (int i = 0; i < m_fileNumber; i++) {
				//...
			}
		}
	};

先其中添加一个进度条，显示分隔进度：

	class MainForm : public Form
	{
		TextBox * txtFilePath;
		TextBox * txtFileNumber;
		ProgressBar * progressBar;
	public:
		void Button1_Click() {
			string filePath = txtFilePath->getText();
			int number = atoi(txtFileNumber->getText()).c_str();
	
			FileSplitter splitter(filePath, number, progressBar);
	
			splitter.split();
		}
	};
	
	class FileSplitter {
		string m_filePath;
		int m_fileNumber;
		ProgressBar * m_progressBar;
	public:
		FileSplitter(const string& filePath, int fileNumber, ProgressBar * progressBar) :
			m_filePath(filePath),m_fileNumber(fileNumber), m_progressBar(progressBar){
		}
	
		void split() {
			//1.读取大文件
			//2. 分批次先小文件中写入
			for (int i = 0; i < m_fileNumber; i++) {
				//...
				if (m_progressBar != NULL)
					m_progressBar->setVaule((i+1)/m_txtFileNumber); //更新进度条
			}
		}
	};

上面这种进度条是基于GUI，但是有时候需要显示百分比，或者在Linux下打印“-”等等形式，这样就需要修改FileSpliteer类。这就违反了依赖倒置原则，m_progressBar不应该是一个具体的对象，而应该是一个接口。

	class MainForm : public Form, public IProgress
	{
		TextBox * txtFilePath;
		TextBox * txtFileNumber;
		ProgressBar * progressBar;
	
	public:
		void Button1_Click() {
			string filePath = txtFilePath->getText();
			int number = atoi(txtFileNumber->getText()).c_str();
	
			FileSplitter splitter(filePath, number, this);
	
			splitter.split();
		}
	
		void DoProgress(float value){
			progressBar->value(value);
		}
	};


​	
	class IProgress {
		virtual void DoProgress(float value) = 0;
		virtual ~IProgress() {}
	};
	class FileSplitter {
		string m_filePath;
		int m_fileNumber;
		//ProgressBar * m_progressBar; //具体通知控件
		IProgress * m_iprogress; //抽象通知机制
	public:
		FileSplitter(const string& filePath, int fileNumber, IProgress * iprogress) :
			m_filePath(filePath), m_fileNumber(fileNumber), m_iprogress(iprogress) {
		}
	
		void split() {
			//1.读取大文件
	
			//2. 分批次先小文件中写入
			for (int i = 0; i < m_fileNumber; i++) {
				//...
				//m_progressBar->setVaule();
				float progressValue = m_fileNumber;
				progressValue = (i + 1) / progressValue;
				onProgress(progressValue);
			}
		}
	protected:
		void onProgress(float vaule) {
			if (m_iprogress != nullptr) {
				m_iprogress->DoProgress(vaule); //更新进度条
			}
		}
	};

这是上面的一个观察者，仅支持一个通知。下面的代码可以支持多个观察者：
	
	class MainForm : public Form, public IProgress
	{
		TextBox * txtFilePath;
		TextBox * txtFileNumber;
		ProgressBar * progressBar;
	
	public:
		void Button1_Click() {
			string filePath = txtFilePath->getText();
			int number = atoi(txtFileNumber->getText()).c_str();
	
			FileSplitter splitter(filePath, number);
			ConsoleNotifer cn;
			splitter.addIProgressList(this);
			splitter.addIProgressList(&cn);
	
			splitter.split();
		}
	
		void DoProgress(float value) {
			progressBar->value(value);
		}
	};
	class ConsoleNotifer : public IProgress {
	public:
		virtual void DoProgress(float value) {
			cout << ".";
		}
	};
	
	class IProgress {
		virtual void DoProgress(float value) = 0;
		virtual ~IProgress() {}
	};
	class FileSplitter {
		string m_filePath;
		int m_fileNumber;
		//ProgressBar * m_progressBar; //具体通知控件
		List<IProgress*> m_iprogressList; //抽象通知机制,支持多个观察者
	public:
		FileSplitter(const string& filePath, int fileNumber) :
			m_filePath(filePath), m_fileNumber(fileNumber) {
		}
		void addIProgressList(IProgress * progress) {
			m_iprogressList.add(progress);
		}
		void removeProgressList(IProgress * progress){
			m_iprogressList.remove(progress);
		}
		void split() {
			//1.读取大文件
	
			//2. 分批次先小文件中写入
			for (int i = 0; i < m_fileNumber; i++) {
				//...
				//m_progressBar->setVaule();
				float progressValue = m_fileNumber;
				progressValue = (i + 1) / progressValue;
				onProgress(progressValue);
			}
		}
	protected:
		void onProgress(float vaule) {
			auto ite = m_iprogressList.begin();
			while (ite != m_iprogressList.end())
			{
				(*ite)->DoProgress(vaule); //更新进度条
				ite++;
			}
			
		}
	};

#### 定义

定义对象间的一种一对多（变化）的依赖关系，以便当一个对象（Subject）的状态发生变化时，所有依赖于它的对象都得到通知并自动更新。

设计结构：

![](https://i.imgur.com/j1O4LF3.png)

Observer对应IProgress, Update()相等于DoProgress()。Attach(Observer)相等于addIProgressList(IProgress*)，Detach相等于removeProgressList，只不过上面程序没有分开成一个单独的基类，Notify()相等于OnProgress()。ConcreteSubject就是上面的FileSplitter。ConCreteObserver就是MainForm或者ConsoleNofier，即一个具体的观察者。有时候，将Subject和ConcreteSubject放在一个类中，上述代码就是这样。

要点总结：

- 使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达到松耦合。
- 目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。
- 观察者自己决定是否需要订阅通知，目标对象对此一无所知。
- Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。


## 单一职责模式

在软件组件的设计中，如果责任划分不清晰，使用继承得到的结果往往是随着需要的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。

典型模式：

- Decorator
- Bridge

这两个模式在单一职责上表现得特别明显，其他模式也可能具有单一职责特性。


### Decorate(装饰模式)

#### 动机 

- 在某些情况下，我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。
- 如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响降为最低？

场景：流操作。

![](https://i.imgur.com/vsCkan9.png)


​	
	class Stream {
	public:
		virtual char Read(int number) = 0;
		virtual void Seek(int position) = 0;
		virtual void Write(char data) = 0;
		virtual ~Stream(){}
	};
	
	class FileStream : public Stream
	{
	public:
		virtual char Read(int number) {
			//读文件流
		}
		virtual void Seek(int position) {
			//定位文件流
		}
		virtual void Write(char data) {
			//写文件流
		}
	};
	
	class NetWorkStream : public Stream {
	public:
		virtual char Read(int number) {
			//读网络流
		}
		virtual void Seek(int position) {
			//定位网络流
		}
		virtual void Write(char data) {
			//写网络流
		}
	};


​	
	class MemoryStream : public Stream {
	public:
		virtual char Read(int number) {
			//读内存流
		}
		virtual void Seek(int position) {
			//定位内存流
		}
		virtual void Write(char data) {
			//写内存流
		}
	};
	
	class CryptoFileStream : public FileStream {
	public:
		virtual char Read(int number) {
			//额外的加密操作
			FileStream::Read(number);//读文件流
		}
		virtual void Seek(int position) {
			//额外的加密操作
			FileStream::Seek(position);//定位文件流
			//额外的加密操作
		}
		virtual void Write(char data) {
			//额外的加密操作
			FileStream::Write(data);//定位文件流
			//额外的加密操作
		}
	};


​	
	class CryptoNetWorkStream : public NetWorkStream {
	public:
		virtual char Read(int number) {
			//额外的加密操作
			NetWorkStream::Read(number);//读文件流
		}
		virtual void Seek(int position) {
			//额外的加密操作
			NetWorkStream::Seek(position);//定位文件流
			//额外的加密操作
		}
		virtual void Write(char data) {
			//额外的加密操作
			NetWorkStream::Write(data);//定位文件流
			//额外的加密操作
		}
	};
	
	class CryptoMemoryStream : public MemoryStream {
	public:
		virtual char Read(int number) {
			//额外的加密操作
			MemoryStream::Read(number);//读文件流
		}
		virtual void Seek(int position) {
			//额外的加密操作
			MemoryStream::Seek(position);//定位文件流
			//额外的加密操作
		}
		virtual void Write(char data) {
			//额外的加密操作
			MemoryStream::Write(data);//定位文件流
			//额外的加密操作
		}
	};
	
	//缓冲
	class BufferedFileStrem : public FileStream {
		//...
	};
	class BufferedNetWorkStrem : public FileStream {
		//...
	};
	class BufferedMemoryStrem : public FileStream {
		//...
	};
	
	//即缓冲又加密
	class CryptoBufferedFileStream : public FileStream {
	public :
		virtual char Read(int number)
		{
			//额外的加密操作
			//额外的缓冲操作
			FileStream::Read(number); //读文件流
		}
		//...
	};
	class CryptoBufferedNetworkStream : public NetWorkStream {
	public:
		virtual char Read(int number)
		{
			//额外的加密操作
			//额外的缓冲操作
			NetWorkStream::Read(number); //读文件流
		}
		//...
	}; class CryptoBufferedMemoryStream : public MemoryStream {
	public:
		virtual char Read(int number)
		{
			//额外的加密操作
			//额外的缓冲操作
			MemoryStream::Read(number); //读文件流
		}
		//...
	};
	
	void Process() {
		CryptoFileStream * fs1 = new CryptoFileStream();
		BufferedFileStrem * fs2 = new BufferedFileStrem();
		CryptoBufferedFileStream * fs3 = new CryptoBufferedFileStream();
	}


第二版：


	class Stream {
	public:
		virtual char Read(int number) = 0;
		virtual void Seek(int position) = 0;
		virtual void Write(char data) = 0;
		virtual ~Stream(){}
	};
	
	class FileStream : public Stream
	{
	public:
		virtual char Read(int number) {
			//读文件流
		}
		virtual void Seek(int position) {
			//定位文件流
		}
		virtual void Write(char data) {
			//写文件流
		}
	};
	
	class NetWorkStream : public Stream {
	public:
		virtual char Read(int number) {
			//读网络流
		}
		virtual void Seek(int position) {
			//定位网络流
		}
		virtual void Write(char data) {
			//写网络流
		}
	};


​	
	class MemoryStream : public Stream {
	public:
		virtual char Read(int number) {
			//读内存流
		}
		virtual void Seek(int position) {
			//定位内存流
		}
		virtual void Write(char data) {
			//写内存流
		}
	};
	
	//扩展操作
	class CryptoStream : public Stream{
		Stream * stream;//...
	public:
		CryptoStream(Stream * stream) {
			this->stream = stream;
		}
		virtual char Read(int number) {
			//额外的加密操作
			stream->Read(number);//读文件流
		}
		virtual void Seek(int position) {
			//额外的加密操作
			stream->Seek(position);//定位文件流
			//额外的加密操作
		}
		virtual void Write(char data) {
			//额外的加密操作
			stream->Write(data);//定位文件流
			//额外的加密操作
		}
	};


​	
	//缓冲
	class BufferedStream : public Stream {
		Stream * stream;
		//...
	public:
		BufferedStream(Stream * stm) :stream(stm) {
	
		}
	};
	
	void Process() {
		//运行时装配
		FileStream * s1 = new FileStream();
		CryptoStream * s2 = new CryptoStream(s1); //加密
		BufferedStream * s3 = new BufferedStream(s1); //缓冲
		BufferedStream * s4 = new BufferedStream(s2); //即加密又缓冲
	}


第三步，添加一个中间层，装饰层


	class Stream {
	public:
		virtual char Read(int number) = 0;
		virtual void Seek(int position) = 0;
		virtual void Write(char data) = 0;
		virtual ~Stream(){}
	};
	
	class FileStream : public Stream
	{
	public:
		virtual char Read(int number) {
			//读文件流
		}
		virtual void Seek(int position) {
			//定位文件流
		}
		virtual void Write(char data) {
			//写文件流
		}
	};
	
	class NetWorkStream : public Stream {
	public:
		virtual char Read(int number) {
			//读网络流
		}
		virtual void Seek(int position) {
			//定位网络流
		}
		virtual void Write(char data) {
			//写网络流
		}
	};


​	
	class MemoryStream : public Stream {
	public:
		virtual char Read(int number) {
			//读内存流
		}
		virtual void Seek(int position) {
			//定位内存流
		}
		virtual void Write(char data) {
			//写内存流
		}
	};
	
	//扩展操作
	
	class DecoratorStream : public Stream{
	protected:
		Stream * stream;
	public:
		DecorateStream(Stream * stm) {
			stream = stm;
		}
	};
	class CryptoStream : public DecoratorStream {
	public:
		CryptoStream(Stream * stream):DecoratorStream(stream){
		}
		virtual char Read(int number) {
			//额外的加密操作
			stream->Read(number);//读文件流
		}
		virtual void Seek(int position) {
			//额外的加密操作
			stream->Seek(position);//定位文件流
			//额外的加密操作
		}
		virtual void Write(char data) {
			//额外的加密操作
			stream->Write(data);//定位文件流
			//额外的加密操作
		}
	};


​	
	//缓冲
	class BufferedStream : public DecoratorStream {
	
		//...
	public:
		BufferedStream(Stream * stm) :DecoratorStream(stm) {
	
		}
	};
	
	void Process() {
		//运行时装配
		FileStream * s1 = new FileStream();
		CryptoStream * s2 = new CryptoStream(s1); //加密
		BufferedStream * s3 = new BufferedStream(s1); //缓冲
		BufferedStream * s4 = new BufferedStream(s2); //即加密又缓冲
	}

第三版类的关系图：

![](https://i.imgur.com/gkgZZnW.png)

第一个版本中全部使用继承，所以导致类数量规模特别大。而第二版和第三版我们改成使用对象组合，引出多态变化，使得类数量大大减少。

#### 定义

动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码，并减少子类个数）

设计结构：

![](https://i.imgur.com/I0eR86U.png)

Component类对应我们代码中是Stream类，Decorator类对应位DecoratorStream类，ConcreteComponent类对应为FileStream类、MemoryStream类和NetWorkStream类，ConcreterDecoratorA和ConcreterDecoratorB类对应为CryptoStream类和BufferedStream类。

其中红色框内的类是稳定的，而蓝色框内的类是变化的。

总结

- 通过采用组合而非继承的手法，Decorator模式实现了在运行是动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。
- Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。
- Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。


### Bridge(桥模式)

#### 动机

- 由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个维度的变化。
- 如何应对这种”多维度的变化“？如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方面变化，而不引入额外的复杂度？



#### 定义

将抽象部分（业务功能）与实现部分（平台实现）分离，使它们都可以独立地变化。


![](https://i.imgur.com/cRdBUrF.png)

总结：

- Bridge模式使用”对象间得组合关系“解耦了抽象和实现之间固有得绑定关系，使得抽象和实现可以沿着各自得维度来变化。所谓抽象和实现沿着各自维度的变化，即”子类化“它们。
- Bridge模式有时候类似于多继承方法，但是多继承方法往往违背单一职责（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方法更好的解决办法。
- Bridge模式的应用一般在”两个非常强的变化维度“，有时一个类也有多于两个的变化维度，这是可以使用Bridge的扩展模式。


## 对象创建模式

通过"对象创建"模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。

典型模式：

- Factory Method: 工厂方法
- Abstract Factory：抽象工厂
- Prototype：原型
- Builder：构建器

### Factory Method（工厂方法模式）

- 在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建对象的具体类型经常变化。
- 如何应对这种变化？如何绕过常规的对象创建方法（new），提供一种”封装机制“来避免客户程序和这种”具体对象创建工作“的紧耦合？


定义：

定义一个用户创建对象的接口，让子类来决定实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。

创建对象的接口： SplitterFactory

子类： BinarySplitterFactory

![](https://i.imgur.com/LMEAM9D.png)

Product: ISplitter

ConcreteProduct: BinarySplitter ...

Creator : SplitterFactory

ConcreteCreator: BinarySplitterFactory ...

蓝色是变化的，红色是稳定的。

总结：

- Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系（new）会导致软件的脆弱。
- Factory method模式通过面向对象的手法，将索要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种耦合关系。
- Factory Mathod模式解决“单个对象”的需要变化。缺点在于要创建方法/参数相同。


### Abstract Factory抽象工厂

- 在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。
- 如何应对这种变化？如何绕过常规的对象创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？

定义：

提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。

结构：

![](https://i.imgur.com/v3YxJrG.png)

AbstractFactory： IDBFactory

ConcreteFactory1: SqlDBFactory

ConCreteFactoyr2: OracleDBFactory

AbstractProductA: IDBConnection

AbstractProductB: IDBCommand

ProductA1: SqlConnection  ProductA2: OracleConnection

ProductB1: SqlCommand     ProductB2: Oraclecommand

总结：

- 如果没有应对“多系列对象构建”的需求变化，则没有必要使用Abstract Factory模式，这时候使用简单的工厂完全可以。
- ”系列对象“指的是在某一个特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖。
- Abstract Factory模式主要在于应对”新系列“的需求变动。其缺点在于难以应对”新对象“的需求变动。


### Prototype（原型模式）


- 在软件系统中，经常面临着”某些结构复杂的对象“的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。
- 如何应对这种变化？如何向”客户程序（使用这些对象的程序）“隔离出”这些易变对象“，从而使得”依赖这些易变对象的客户程序“不随着需求改变而改变？


定义：

使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。

![](https://i.imgur.com/veFzJtw.png)

Protoype: ISpillter

ConcretePrototype1: BinarySplitterFacory

总结：

- Prototype模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类“拥有”稳定的接口“。
- Prototype模式对于”如何创建易变类的实体对象“采用”原型克隆“的方法来做，它使得我们可以非常灵活地动态创建”拥有某些稳定接口“的新对象——所需工作仅仅是注册一个新类的对象（即原型），然后在任何需要的地方Clone。
- Prototype模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝。

### Builder（构建器）

- 在软件系统中，有时候面临着”一个复杂对象“的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法相对稳定。
- 如何应对这种变化？如何提供一种”封装机制“来隔离出”复杂对象的各个部分“的变化，从而保持系统中的”稳定构建算法“不随着需求改变而改变？

定义：

将一个复杂对象的构建与其表示相分离，使得同样的构建过程（稳定）可以创建不同的表示（变化）。


![](https://i.imgur.com/KSSRVsX.png)

总结：

- Builder模式主要用于”分步骤构建一个复杂的对象“。在这其中”分步骤“是一个稳定的算法，而复杂对象的各个部分则经常变化。
- 变化点在哪里，封装哪里——Builder模式主要在于应对”复杂对象各个部分“的频繁需求变动。其缺点在于难以应付”分步骤构建算法“的需求变动。
- 在Builder模式中，要注意不同的语言中构造器内调用虚函数的差别。

## 对象性能模式

面向对象很好地解决了“抽象”的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。

- Singleton
- FlyWeight(享元模式)

### Singleton（单件模式）

动机：

- 在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。
- 如何绕过常规的构造器，提供一个机制来保证一个类只有一个实例？
- 这应该是类设计者的责任，而不是使用者的责任。


定义：

保证一类仅有一个实例，并提供一个该实例的全局访问点。

总结：

- Singleton模式中的实例构造器可以设置为protected以允许类派生。
- Singleton模式一般不要支持拷贝构造函数和Clone接口，因为这有可能导致多个对象实例，与Singleton模式的初衷违背。
- 如何实现多线程环境下安全的Singleton？注意对双检查锁的正确实现。

### FlyWeight(享元模式)

动机：

- 在软件系统采用纯粹对象方法的问题处在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价——主要指内存需求方面的代价。
- 如何避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作？

模式定义：

运用共享技术有效地支持大量细粒度的对象。

![](https://i.imgur.com/evwgHu7.png)

总结：

- 面向对象很好地解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。
- Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。
- 对象的数量太大从而导致对象内存开销加大——什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断。



## 接口隔离模式

在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来相互紧密关联的接口是一种常见的解决方案。

典型模式

- Facade
- Proxy
- Adapter
- Mediator

### Faceade(门面(界面)模式)

系统间耦合的复杂度

![](https://i.imgur.com/GKdJzAC.png)

动机：

- 上述A方案的问题在于组件的客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临着很多变化的挑战。
- 如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦？

定义：

为子系统中的一组接口提供一个一致（稳定）的接口，Facade模式定义了一个高层接口，这个接口使得这一个子系统更佳容易使用（复用）。

总结：

- 从客户程序的角度来看，Facade模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种“解耦”的效果——内部子系统的任何不会影响到Facade接口的变化。
- Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种架构设计模式。
- Facade设计模式并非一个集装箱，可以任意地放进任何多个对象。Facade模式中组件的内部应该是“相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。

该模式没有一种特定的代码结构，所以没有代码分析。


### Proxy(代理模式)

动机：

- 在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦。
- 如何在不失去透明操作对象的同时来管理/控制这些对象特有的复杂性？增加一层间接层是软件开发中常见的解决方式。


定义：

为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问。

![](https://i.imgur.com/sqheZSF.png)

总结：

- “增加一层间接层”是软件系统中对许多复杂问题的一种常见解决方法。在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的proxy对象便是解决这一问题的常用手段。
- 具体proxy设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如copy-on-write技术，有些可能对组件模块提供抽象代理层，在架构层次对对象做proxy。
- Proxy并不一定要保持接口完成的一致性，只要能够实现间接控制，有时候损失一些透明性是可以接受的。




### Adapter(适配器)

动机：

- 在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。
- 如何应对这种“迁移的变化”？如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？

定义：

将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。


![](https://i.imgur.com/HUkUxAR.png)


Adapter实现了从Adptee到Target的转换。


总结：

- Adpater模式主要应用于“希望复用一些现存的类，但是接口又与复用的环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。
- GoF 23定义了两种Adapter模式的实现结构：对象适配器和类适配器。但类适配器采用“多继承”的实现方式，一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦精神。
- Adapter模式可以实现的非常灵活，不必拘泥于Gof23中定义的两种接口。例如，完全可以将Adapter模式中的e“现存对象”作为新的接口方法参数，来达到适配的目的。



### 中介者(Mediator)

动机：

- 在软件构建过程中，经常会出现多个对象相互关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。
- 在这种情况下，我们可使用一种“中介对象”来管理对象间的关联关系，避免相互交互的对象之间的紧耦合引用关系，从而更好地抵御变化。

定义：

用一个中介对象来封装（封装变化）一系列的对象交互。中介者使各对象不需要显式的相互引用（编译时依赖→运行时依赖），从而使其耦合松散（管理变化），而且可以独立地改变它们之间的交互。


![](https://i.imgur.com/FcFPMtf.png)

更加形象的结构图：

![](https://i.imgur.com/4V8TIZo.png)

总结：

- 将多个对象间复杂的关联关系解耦，Mediator模式间多个对象间的控制逻辑进行集中管理，变“多个对象互相关联”为“多个对象和一个中介者关联”，简化了系统的维护，抵御了可能的变化。
- 随着控制逻辑的复杂化，Mediator具体对象的实现可能相当复杂。这时候可以对Mediator对象进行分解处理。
- Facade模式是解耦系统间（单向）的对象关联关系；Mediator模式使解耦系统内各个对象之间（双向）的关联关系。

## 状态变化模式

在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化”模式为这一问题提供了一种解决方案。

典型模式：

- State
- Memento

### State(状态模式)

动机：

- 在软件构建过程中，某些对象的状态如果变化，其行为也会随之发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可以完全不同。
- 如果在运行时根据对象的状态来透明地更改对象的行为？而不会为对象操作和状态转化之间引入紧耦合？

定义：

允许一个对象在其内部状态改变它的行为。从而使对象看起来似乎修改了其行为。

![](https://i.imgur.com/w8juT8b.png)


总结：

- State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中，在对象状态切换时，切换相应的对象；但同时维持State的接口，这样实现了具体操作与状态切换之间的解耦。
- 为不同的状态引入的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的——即要么彻底转换过来，要么不转换。
- 如果State对象没有实例变量，那么各个上下文可以共享同一State对象，从而节省对象开销。



### Memento(备忘录模式)

动机：

- 在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些公有接口来让其对象得到对象的状态，便会暴露对象的细节实现。
- 如何实现对象状态的良好保存与恢复？但同时又不会因此而破坏对象本身的封装性。

定义：

在不破化封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。

![](https://i.imgur.com/mau83sl.png)

总结：

- 备忘录（Memento）存储原发器（Originator）对象的内部状态，在需要时恢复原发器状态。
- Memento模式的核心是信息隐藏，即Originator需要向外隐藏信息，保持其封装性。但同时又需要将状态保存到外界（Memento）。
- 由于现代语言运行时（如C#,java等）都具有相当的对象序列化支持，因此往往采用效率较高、又较容易正确实现的序列化方法来实现Memento模式。

## 数据结构模式

常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。

典型模式：

- Composite
- Iterator
- Chain of Resposibility 

### Composite(组合模式)

动机：

- 在软件某些情况下，客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。
- 如何将“客户代码与复杂的对象容器结构”解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器？

定义：

将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性（稳定）。


![](https://i.imgur.com/5ndRxkW.png)

总结：

- Composite模式采用树形结构来实现普遍存在的对象容器，从而将“一对多”的关系转化为“一对一”的关系，使得客户代码可以一致地（复用）处理对象和对象容器，无需关系处理的是单个的对象，还是组合的对象容器。
- 将“客户代码与复杂的对象容器结构”解耦是Composite的核心思想，解耦之后，客户代码将与纯粹的抽象接口——而非对象容器的内部实现结构——发生依赖，从而更能“应对变化”。
- Composite模式在具体实现中，可以让父对象中的子对象方向追随；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。

### Iterator(迭代器模式)

动机：

- 在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种“透明遍历”也为“同一种算法在多种集合对象上进行操作”提供了可能。
- 使用面向对象技术将这种遍历机制抽象为“迭代器对象”为“应对变化中的集合对象”提供了一种优雅的方式。

定义：

提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示。

![](https://i.imgur.com/T8WmrEK.png)

注意：这种模式已经过时，一般采用泛型编程的迭代器。

总结：

- 迭代抽象：访问一个聚合对象的内线而无需暴露它的内部表示。
- 迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。
- 迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构会导致问题。

### Chain of Resposibility(职责链模式)

动机：

- 在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接收者，如果显式指定，将必不可少地代理请求发送与接收者的紧耦合。
- 如何使请求的发送者不需要指定具体的接收者？让请求的接收者自己在运行时决定来处理请求，从而使两者解耦。

定义：

使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。


![](https://i.imgur.com/yJj68Gh.png)


总结：

- Chain of Resposibility模式的应用场合在于“一个请求可能有多个接收者，但是最后真正的接收者只有一个”，这时候请求发送者与接收者的耦合有可能出现“变化脆弱”的症状，职责链的目的就是将二者解耦，从而更好地应对变化。
- 应用了Chain of Resposibility模式后，对象的职责分派将更具有灵活性。我们可以在运行时动态添加/修改请求的处理职责。
- 如果请求传递到职责链的末尾仍得不到处理，应该有一个合理缺省机制。这也是每一个接收对象得责任，而不是发出请求得对象得责任。


注意：该模式也已经过时。


## 行为变化模式 

在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化”模式将组件的行为和组件本身进行金瓯，从而支持组件行为的变化，实现两者之间的松耦合。

典型模式：

- Command
- Vistor

### Command(命令模式)

动机：

- 在软件构建过程中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合——比如需要对行为进行“记录、撤销/重（undo/redo）、事务”等处理，这种无法抵御变化的紧耦合是不适用的。
- 在这种情况下，如何将“行为请求者”与“行为是想着”解耦？将一组行为抽象为对象，可以实现两者之间的松耦合。】


定义：

将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及持支可撤销的操作。

![](https://i.imgur.com/nMQ6Qzm.png)

总结：

- Command模式的根本目的在于将“行为请求者”与“行为实现者”解耦，在面向对象语言中，常见的实现手段是“将行为抽象为对象”。
- 实现Command接口的具体命令对象ConcreteCommand有时候根据需要可能会保存一些额外的状态信息。通过使用Composite模式，可以将多个“命令”封装为一个“符合命令”MacroCommand。
- Command模式与C++中的函数对象有些类似。但两者定义行为接口的规范有所区别：Command以面向对象中的“接口-实现”来定义行为接口规矩，更严格，但有性能损失；C++函数对象以函数签名来定义行为接口规范，更灵活，性能更高。

### Vistor(访问器模式)

动机：

- 在软件构建过程中，由于需求的变化，某些类层次结构中常常需要增加新的方法，如果直接在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。
- 如何在不更改类层次结构的前提下，在运行时根据需要透明地为类层次结构上的各个类动态添加新的操作，从而避免上述问题？

定义：

表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（稳定）各元素的类的前提下定义（扩展）作用于这些元素的新操作（变化）。

![](https://i.imgur.com/okHsclo.png)

注意：Element的子类的数量一定不能变，而且子类不能更改。

总结：

- Visitor模式通过所谓双重分发（double dispatch）来实现不更改（不添加新的操作-编译时）Element类层次结构的前提下，在运行时透明地为类层次结构的各个类动态添加新的操作（支持变化）。
- 所谓双重分发即Visitor模式中间包括了两个多态分发（注意其中的多态机制）：第一个为accept方法的多态辨析；第二个为visitElementX方法的多态辨析。
- Visitor模式的最大缺点在于扩展类层次结构，会导致Visitor类的改变。因此Visitor模式适用于“Element类层次结构稳定，而其中的操作却经常面临频繁改动”。


## 领域规则模式

在特定领域，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案。

典型模式： Interpreter

### Interpreter(解析器模式)

动机：

- 在软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果使用普通的编程方式来实现面临非常频繁的变化。
- 在这种情况下，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。

代码中对应的计算表达式：

![](https://i.imgur.com/trfzu5c.png)

定义：

给定一种语言，定义它的文法的一种表示，并顶一个一种解释器，这个解释器使用该表示来解释语言中的句子。

![](https://i.imgur.com/pRWHiGV.png)

TerminalExpression:相当于代码中变量表达式

NonterminalExpression：相当于代码中的符号表达式

总结：

- Interpreter模式的应用场合是Interpreter模式应用中的难点，只有满足“业务规则频繁变化，且类似的结构不断重复出现，并且容易抽象为语法规则的问题”才适合使用interpreter模式。
- 使用Interpreter模式来表达文法规则，从而可以使用面向对象技巧来方便地“扩展文法”。
- Interpreter模式比较使用简单的文法表示，对于复杂的文法表示，Interperter模式会产生比较大的类层次结构，需要求助于语法分析生成器这样的标准工具。


## 总结

### 一个目标：

管理变化，提供复用！


### 两个手段：

分解 vs 抽象

### 八大原则：

- 依赖倒置
- 开放封闭原则
- 单一职责原则
- Liskov替换原则
- 接口隔离原则
- 对象组合优于类继承
- 封装变化点
- 面向接口编程


### 重构技巧：

静态 -> 动态

早绑定 -> 晚绑定

继承 -> 组合

编译时依赖 -> 运行时依赖

紧耦合 -> 松耦合

### 模式分类

![](https://i.imgur.com/6pdgMH0.png)


不常用的： Builder、Mediator、Memento、Iterator、Chain of REsposibility、Command、Interpreter

C++对象模型：

![](https://i.imgur.com/ucRfqWn.png)

第三种对象模型中，模式都是通过一个指针来指向一个多态对象。

什么时候不用模式：

- 代码可读性很差时
- 需求理解还很浅时
- 变化没有显现时
- 不是系统的关键依赖点
- 项目没有复用价值时
- 项目将要发布时

经验之谈：

- 不要为模式而模式
- 关注抽象类&接口
- 理清变化点和稳定点
- 审视依赖关系
- 要有Framework和Application的区隔思维
- 良好的设计是演化的结果


设计模式成长之路：

- “手中无剑，心中无剑”：见模式而不知
- “手中有剑，心中无剑”：可以识别模式，作为应用开发人员使用模式
- “手中有剑，心中有剑”：作为框架开发人员为应用设计某些模式
- “手中无剑，心中有剑”：忘掉模式，只有原则


资料：[https://blog.csdn.net/liang19890820/article/category/6783147](https://blog.csdn.net/liang19890820/article/category/6783147)