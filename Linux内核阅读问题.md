---

title: Linux内核分析
date: 2019-06-11 13:44:14
tags: Linux
mathjax: true

---

Linux内核介绍，以及内核中C语言的特点！<!--more-->

## 内核开发特点

### 无libc库或无标准头文件

Linux内核无法使用C语言的库函数，但是Linux内核实现了这些库函数，实现的文件(即.c文件)包含在lib目录下，头文件(即.h文件)在include\linux目录下。

基本的头文件位于include\linux目录下；体系结构相关的头文件位于内核源代码数的arch/<architecture>/include/asm目录下。比如如果编译的是x86体系结构，则体系结构相关的头文件就是arch/x86/include/asm

使用的时候包含如下头文件：

	//包含基本头文件
	#include <linux/string.h>
	//包含体系结构相关的头文件
	#include <asm/ioctl.h>

内核肯定无法调用printf，但是其提供了printk函数，几乎与printf()相同。printk()函数负责把格式化好的字符串拷贝到内核日志缓冲区上，这样syslog程序就可以通过读取该缓冲区来获取内核信息。printk()用法：

	printk("Hello world! A string: '%s' and an integer: '%d'\n", str ,i);

printk()与printf()的一个区别在于，printk()允许你通过一个标志来设置优先级。syslog会根据这个优先级标志来决定在什么地方显示这条系统信息。下面是一个车使用这种优先级标志的例子：

	printk(KERN_ERR "This is an error!\n");

注意:KERN_ERR和要打印的消息之间没有逗号。优先级标志是预处理程序定义的一个描述性字符串，在编译时优先级标志与要打印的信息绑定在一起处理。

### GNU C

Linux使用的是GNU C。

C语言扩展：

- inline函数：函数会在他所调用的位置上展开，这样会消除函数调用和返回所带来的开销。代价是代码会变长，占用更多的内存空间。所以经常把对时间要求比较高，而本身长度比较短的函数定义为内敛函数。

定义内敛函数时，需要使用static作为关键字，并且用inline限定他。比如：
	
	static inline void wolf(unsigned long tail_size)
	{ ...}

使用static限制，编译时不会为内联函数单独建立一个函数体。

为了安全险，优先使用内联函数，而不是复杂的宏

- 内联汇编

C函数中可以嵌入汇编指令。

通常使用asm()指令来嵌入汇编代码。

在偏近体系结构的底层或对执行时间要求严格的地方，一般使用汇编语言；而内核的其他部分使用C语言。

- 分支声明

对于条件选择语句，gcc内建了一条指令用于优化，在一个条件经常出现，或者该条件很少出现的时候，编译器可以根据这条指令对条件分支选择进行优化。内核把这条指令封装成了宏，比如likely()和unlikely()，这样使用起来比较方便。

例如，普通的分支声明：

	if (error) {...}

如果想要把这个选择标记成绝少发生的分支：

	if(unlikely(error)) {...}

相反，如果我们想把一个分支标记成通常为真的选择：

	if(likely(error)) {...}


### 内有内存保护机制

如果一个用户程序视图进行一次非法的内存访问，内核就会出现错误，发送SIGSEGV信号，并结束进程。

如果是内核自己非法访问了内存，那后果加很难控制了。内核中发生的内存错误会导致oops，这是内存中出现的最常见的一类错误。在内核中，不应该取访问非法的内存地址，引用控制住，否则会死掉，却根本不告诉你。

内核中的内存都不分页。即，你用掉一个字节，物理内存就减少一个字节。

### 不要轻易在内核中使用浮点数

用户空间的进程内进行浮点数操作的时候，内核会完成从整数操作到浮点数操作的模式转换。

而内核空间并不能完美地支持浮点操作，因为它本身不能陷入。在内核中使用浮点数，除了要人工保存和恢复浮点寄存器，还有其他一些琐碎的事情要做。

总之，在内核，不要进行浮点数操作。

### 容积小而固定的栈

用户空间的成协商可以从栈上分配大量的空间来存放变量，甚至巨大的结构体和数组等。这是因为用户空间的栈本身很大，而且还可以动态增长。

而内核栈的准确大小随体系结构而变。内核栈的大小是两页，即32位机内核栈是8KB，而64位机是16KB，这是固定不变的。每个处理器都有自己的栈。

### 同步和并发

内核很容器产生竞争条件。和单线程的用户空间程序不同，内核的特性要求能够并发地访问共享数据，这就要求同步机制以保证不出现竞争条件。

### 可移植性的重要性

用户空间的成协商不太注意移植问题，然而Linux却是一个可移植的操作系统，并且一直保持这种特点。即，大部分C代码应该与体系结构无关。

## 2 进程管理

### 2.1 进程

进程是出于执行期的程序以及相关的资源的总称。存在多个进程执行的是同一个程序，并且多个并存的进程还可以共享地址空间等资源。

线程是在进程中活动的对象。在Linux而言，线程只不过是一种特殊的进程罢了。

在现代操作系统中，进程提供了两种虚拟机制：虚拟处理器和虚拟内存。即多个进程在分享一个处理器，但虚拟处理器给进程一种假象，让这些进程觉得自己在独享处理器。

Linux中，通常是调用fork()通过复制一个现有的进程来创建一个全新的进程。调用fork()的进程称为父进程，新产生的进程称为子进程。在调用结束时，在返回点这个相同位置上，父进程恢复执行，子进程开始执行。


exec()这组函数可以创建新的地址空间，并把新的程序载入其中。

在linux内核中，fork()实际上是由clone()系统调用实现的。


exit()系统调用退出执行。这个函数会终结进程并将其占用的资源释放掉。

父进程可以通过wait4()系统调用查询子进程是否终结。

### 2.2 进程描述符及任务结构

内核把进程的列表存放在叫做任务队列的双向循环列表中。链表中的每一项都是类型为task_struct，称为进程描述符的结构，该结构定义在<linux/sched.h>文件中。进程描述符中包含一个具体进程的所有信息。

task_sturct相对比较大。这是由于该结构内包含了内核管理一个进程所需的所有信息。进程描述符中包含的数据能完整地描述一个正在执行的程序：它打开的文件，进程的地址空间，挂起的信号，进程的状态等等。


Linux通过slab分配器分配`task_struct`结构，这样能达到对象复用和缓存着色的目的。由于现在用slab分配器动态生成`task_struct`，所以只需在栈底或栈顶创建一个新的结构`struct thread_info`。`thread_info`头文件在arch\x86\include\asm目录下。

内核通过一个唯一的进程标识值或PID来标识每个进程。PID是一个数，标识为`pid_t`隐含类型，实际上就是一个int类型。PID的最大值默认设置为32768（short int的最大值），尽管这个值可以增加到到达400万（在<linux/threads.h>中所定义的PID最大值的限制）。内核把每个进程的PID存放在它们各自的进程描述符中。


进程描述符中的state描述了进程的当前状态：

- 运行（TASK_RUNNING）
- 可中断（TASK_INTERRUPTIBLE）：进程正在睡眠（即它被阻塞）
- 不可中断（TASK_UNINTERRUPTIBLE）
- `__TASK_TRACED`：被其他进程跟踪的进程
- 停止（`__TAS_STOPPED`）


设置当前进程状态：

`set_task_state(task, state)`函数将制定的进程设置为指定的状态。

`set_current_state(state)`和`set_task_state(current, state)`含义是等同的。

所有进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程。

系统中的每一个进程必有一个父进程，每个进程也可以拥有零个或多个子进程。

每个task_struct都包含一个指向其父进程`tast_sturct`，叫做parent的指针，还包含一个称为children的子进程链表。


### 2.3 进程的创建

首先，fork()通过拷贝当前进程创建一个子进程。子进程与父进程的区别仅仅在于PID和资源的统计量。exec()函数负责读取可执行文件并将其载入地址空间开始运行。这两个函数组合在一起使用的效果跟其他操作系统使用的单一函数一样。


写时拷贝

传统的fork()系统调用直接把所有的资源复制到新创建的进程。这种实现过于简单并且效率低下。Linux的fork()使用写时拷贝页实现。写时拷贝是一个可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。

Linux通过clone()系统调用使用fork()。然后又clone()调用do_fork()。`do_fork()`再调用`_do_fork()`。

`_do_fork()`完成了创建中的大部分工作，它的定义在kernel/forK.c文件中。该函数调用`copy_process()`函数，然后让进程开始运行。

`copy_process()`函数完成的工作：

- 调用`dup_task_struct()`为新进程创建一个内核栈、`thread_info`结构和`task_struct`，这些值与当前进程的值相同。
- 检查并确保新创建这个子进程后，当前用户所拥有的进程数目没有超过它分配的资源限制。
- 子进程着手使自己与父进程区别开来。进程描述符内的许多成员都要被清0或设为初始值。
- 子进程的状态被设置为TASK_UNITERRUPTIBLE，以保证它不会投入运行。
- 调用`copy_flags()`以更新`task_sturct`的flags成员，表明进程是否拥有超级用户权限的`PF_SUPERPRIV`标志被清0，表明进程还没被调用exce()函数的`PF_FORKNOEXEC`标志被设置。
- 调用`alloc_pid()`为新进程分配一个有效的PID。
- 根据创建给clone()的参数标志，`copy_process()`拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间。
- 最后，copy_process()做扫尾工作并返回一个指向子进程的指针。

除了不拷贝父进程的页表项外，vfork()系统调用和fork()的功能相同。由于fork()有了写时拷贝页表现，那么vfork()就彻底没用了。

### 2.4 线程再Linux中的实现

线程机制是现代编程技术中常用的一种抽象概念。该机制提供了在同一程序内共享内存地址空间运行的一组线程。这些线程还可以共享打开的文件和其他资源。

Linux实现线程的机制非常独特。从内核的角度来看，它并没有线程这个概念。Linux把所有的线程当作进程来实现。线程仅仅被视为一个与其他进程共享某些资源的进程，每一个线程都拥有唯一隶属于自己的`task_struct`，所以在内核中，它看起来就是一个普通的进程。

上述的线程机制与Windoes等系统的实现差异非常大。这些系统在内核提供了专门支持线程的机制。这些系统常常把线程称作轻量级进程。

在其他的系统中，相较于重量级的进程，线程被抽象成为一种耗费较少资源，运行迅速的执行单元。而对于Linux，它只是一种进程间共享资源的手段（Linux的进程本身就够轻量级了）。

创建线程：

线程的创建和普通进程的创建类似，只不过调用clone()的时候需要传递一些参数标志了指向需要共享的资源。

内核线程：

内核线程只能由其他内核线程创建。内核是通过从kthreadd内核进程中衍生出所有新的内核线程来自动处理这一点的。在<linux/kthread.h>中申明有接口。于是，从现有内核线程中创建一个新的内核线程的方法如下：

	struct task_struct *kthread_create_on_node(int (*threadfn)(void *data),
						   void *data,
						   int node,
						   const char namefmt[], ...);


内核线程被创建后，如果不通过调用`wake_up_process()`明确唤醒它，它不会主动运行。创建一个并让他运行起来，可以通过调用`thread_run()`来到达，这个函数以宏实现，只是简单的调用`kthread_create()`和`wake_up_process()`。

### 2.5 进程终结

当进程终结时，内核必须释放它所占有的资源并把这一不幸告知父进程。

进程的终结，该任务大部分要靠`do_exit()`来完成（定义在kernel/exit.c）。

调用`do_exit()`之后，线程已经僵死不能再运行，但是系统还保留了它的进程描述符。这样可以让系统有办法在子进程终结后仍能获得它的信息。

如果父进程在子进程之前退出，必须有机制来保证子进程能找到一个新的父进程，否则这些成为孤儿的进程辉在退出时永远处于僵死状态，白白地消耗内存。

解决办法是给子进程在当前线程组内找一个线程作为父进程，如果不行，就让init做它们的父进程。寻找父进程的的函数`find_new_reaper()`。

## 13 虚拟文件系统

虚拟文件系统，简称VFS，作为内核自系统，为用户空间程序提供了文件和文件系统相关的接口。系统中所有文件系统不但依赖VFS共存，而且依靠VFS系统协同工作。通过虚拟文件系统，程序可以利用标准的Unix系统调用对不同的文件系统，甚至不同介质上的文件系统进行读写操作。


VFS使得用户可以直接使用open(),read()和write()这样的系统调用而无需考虑具体文件系统和实际物理介质。

之所以可以使用这种通用接口对所有类型的文件系统进行操作，是因为内核在它的底层文件系统接口上建立一个抽象层。该抽象层使Linux能够支持各种文件系统，即便是他们在功能和行为上存在很大差别。为了支持多文件系统，VFS提供了一个通用文件系统模型，该模型囊括了人任何文件系统的常用功能集和行为。

VFS抽象层之所能衔接各种各样的文件系统，是因为它定义了所有文件系统都支持的、基本的、概念上的接口和数据结构。

在内核中，除了文件系统本身外，其他部分并不需要了解文件系统的内部细节。比如一个简单的用户空间程序执行如下操作：

	ret = write(fd, buf, len);

该系统调用将buf指针指向的长度为len字节的数据写入文件描述符fd对应的文件的当前位置。

这个系统调用首先被一个通用系统调用`sys_write()`处理，`sys_write()`函数要找到fd所在的文件系统实际给出的是哪个操作，然后再执行该操作。


Unix文件系统：

Unix使用了四种和文件系统相关的传统抽象概念：文件、目录项、索引节点和安装点（mount point）。

目录属于普通文件，它记录再其目录下的所有文件。

文件相关信息，包括访问控制权限、大小、拥有者、创建事件等信息，有时被称为文件的元数据，被存储再一个单独的数据结构中，该结构被称为索引节点（inode），其实是index node的缩写。

超级快是一种包含文件系统信息的数据结构，包含文件系统的控制信息。

FAT或NTFS这样的非Unix风格的文件系统，需要经过封装，提供一个符合这些概念的界面，才可以在Linux上工作。比如，即使一个文件系统不支持索引节点，它也必须在内存中装配索引节点结构体。


### VFS对象及其数据结构

VFS其实采用的是面向对象的设计思路，使用一组数据结构来代表通用文件对象。这些数据结构类似于对象，因为内核纯粹使用C代码实现，没有直接利用面向对象的语言，所以内核中的数据结构都是用C语言的结构体实现，而这些结构体包含数据的同时也包含操作这些数据的函数指针，其中的操作函数由具体的文件系统实现。

VFS中由4个主要的对象类型：

- 超级快对象：它代表一个具体的已安装文件系统；
- 索引节点对象：它代表一个具体文件；
- 目录项对象：它代表一个车目录项，是路径的一个组成部分；
- 文件对象：它代表有进程打开的文件。

因为VFS将目录作为一个文件来处理，所以不存在目录对象。目录项代表的是一个路径中的一部分，它可能包括一个普通文件。目录项不同于目录，但目录却是另一种形式的文件。

每个主要对象中都包含一个操作对象，这些操作对象描述了内核针对主要对象可以使用的方法：

- `super_operations`对象，其中包含内核针对特定文件系统所能调用的方法，比如`write_inode()`和`sync_fs()`等方法。
- `inode_operations`对象，其中包含书内核针对特定文件所能调用的方法，比如create()方法和link()等方法。
- `dentry_operations`对象，其中包含内核针对特定目录所能调用的方法，比如`d_compare()`和`d_delete()`等方法。
- `file_operations`对象，其中包括进程针对已打开文件所能调用的方法，比如read()和write()等方法。

操作对象作为一个结构体实现指针来实现，此结构体中包含指向操作其父对象的函数指针。对于其中许多方法来说，可以继承使用VFS提供的通用函数，如果通用函数提供的基本功能无法满足需要，那么就必须使用实际文件系统的独有方法填充这些函数指针，使其指向文件系统实例。

VFS使用了大量的结构体对象，远不止上面四种主要的对象。比如，每个注册的文件系统都由`file_system_type`结构体来表示，它描述了文件系统及其性能；另外，每一个安装点也都用vfsmount结构体表示，它包含的是安装点的相关信息，比如位置和安装标志等。

`fs_struct`结构体和file结构体分别描述了文件系统以及和进程相关的文件。


超级块对象由`super_block`结构体表示，在文件<linux/fs.h>中，创建、管理和撤销超级块对象的代码文娱文件fs/super.c中。超级块对象通过调用`alloc_super()`函数创建并初始化。在文件系统安装时，文件系统会调用该函数以便从磁盘读取文件系统超级块，并且将其信息填充到内存中的超级块对象中。


超级块对象中最重要的一个域是`s_op`，它指向超级块的操作函数表。超级块函数表由`super_operations`结构体表示，定义在<linux/fs.h>中。该结构体中的每一项都是一个指向超级块操作函数的指针，超级块操作函数执行文件系统和索引节点的底层操作。

