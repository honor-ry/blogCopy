---

title:  牛客网C/C++错题集
date: 2019-03-05 13:44:14
tags: C++
mathjax: true

---

牛客网C/C++每天练习十题，记录重要知识点和错题。<!--more-->

### 词法分析器用于识别：__单词__

词法分析是编译的第一阶段。词法分析器的主要任务是读入源程序的输入字符、将他们组成词素（ 源程序中的一个字符序列，它和某个词法单元的模式匹配，并被词法分析器识别为该词法单元的一个实例 ），生成并输出一个词法单元序列，每个词法单元对应一个词素。这个词法单元序列被输出到语法分析器进行语法分析。

编译的过程一般分为6步，：扫描（词法分析）、语法分析、语义分析、源代码优化、代码生成和目标代码优化。


### 结构体地址：

题目：
	
	struct Date
	{
	    char a;
	    int b;
	    int64_t c;
	    char d;
	};

Date data[2][10];在64位系统上，如果Data的地址是x，那么data[1][5].c的地址是（）

a.整体所占的内存大小应该是结构中成员类型最大的整数倍，此处最大的类型是int_64t，占8个字节。即最后所占字节的总数应该是8的倍数，不足的补足；

b.数据对齐原则-内存按结构体成员的先后顺序排列，当排到该成员变量时，其前面所有成员已经占用的空间大小必须是该成员类型大小的整数倍，如果不够，则前面的成员占用的空间要补齐，使之成为当前成员类型的整数倍。假设是地址是从0开始，结构体中第一个成员类型char型占一个字节，则内存地址0-1，第二个成员从2开始，int型所占内存4个字节，根据原则b，第一个成员所占内存补齐4的倍数，故第一个成员所占内存：1 + 3 = 4； 第二个成员占5-8. 第三个成员占8个字节，满足原则b，不需要补齐，占9-16.  第四个成员占一个字节，占17. 故总内存为1 + 3 + 4 + 8 + 1 = 17个字节，但根据原则a，总字节数需是8的倍数，需将17补齐到24.  故此结构体总字节数为：24字节



data[1][5]，意思是前面有15个元素。则第15个元素的起始地址为： 24 * 15 = 360， 即 X + 360
则data[1][5].c的地址为： 360 + 1 + 3 + 4 = 368，即 X + 368


### 枚举定义合法性

在 C 语言中，此定义和语句是合法的：enum aa{ a=5,b,c}bb; bb=(enum aa)5;请问这句话的说法是正确的吗？


enum aa{a=5,b,c} bb;是C语言中定义的枚举类型;意思是：定义aa这个数据类型，其取值范围是a,b,c三个数，其中，a=5, b=6,c=7(如果不给b,c指定数值，就是其前一个数+1)。

同时定义aa 这个数据类型的变量bb, bb = (enum aa)5；和你学到的 int a = (int)b;功能一样，是把数值5转义成(enum aa)数据类型，同时赋值给变量bb;


### include和import

	#import是#include的替代指令，防止重复引用



三个文件：文件A.h  文件B.h  文件C.h  文件C.h需要引入A.h、B.h   ,文件B.h需要引入文件A.h,这样就重复引用了A.h两次，使用#import可以进行优化。

Objective-C 中 #import 和 #include 的区别   

预编译指令
Objective-C：#import
C，C++：#include
	
	#import由gcc编译器支持

在 Objective-C 中，#import 被当成 #include 指令的改良版本来使用。除此之外，#import 确定一个文件只能被导入一次，这使你在递归包含中不会出现问题。

使用哪一个还是由你来决定。一般来说，在导入 Objective-C 头文件的时候使用 #import，包含 C 头文件时使用 #include。

	#import比起#include的好处就是不会引起交叉编译


### 每个C语言程序文件的编译错误分为（ ）类

编译把一个源程序翻译成目标程序的工作过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。按照编译的工作内容推断编译错误可分为词法错误和语法错误

### typedef

用typedef可以定义各种类型名，但不能定义变量
用typedef只是将已存在的类型用一个新的名称代替
使用typedef便于程序的通用


### 指针占几个字节

指针即为地址，指针几个字节跟语言无关，而是跟系统的寻址能力有关。譬如以前是16为地址，指针即为2个字节，现在一般是32位系统，所以是4个字节，以后64位，则就为8个字节


### 为定义行为


未定义行为（Undefined Behavior）是指C语言标准未做规定的行为。同时，标准也从没要求编译器判断未定义行为，所以这些行为有编译器自行处理，在不同的编译器可能会产生不同的结果，又或者如果程序调用未定义的行为，可能会成功编译，甚至一开始运行时没有错误，只会在另一个系统上，甚至是在另一个日期运行失败。当一个未定义行为的实例发生时，正如语言标准所说，“什么事情都可能发生”，也许什么都没有发生。一句话，未定义行为就是运行结果不确定

- 1.变量即是左边结果，又是右边的操作数，如a+=a++，a %= b ^= a ^= b ^= a
- 2.使用越界数组也是C的一个“未定义行为”
- 3.允许一个随便指的指针的读写。
- 4.使用未初始化的变量


下列 C 代码中，不属于未定义行为的有：______

	int i=0;i=(i++);
	char *p=”hello”;p[1]=’E’
	char *p=”hello”;char ch=*p++
	int i=0;printf(“%d%d\n”,i++,i--)
	都是未定义行为
	都不是未定义行为


A错，因为i++返回的是0,而此时i应该是1。然后又让i=0，不同编译器的不同入栈方式，可能得到i=0或i=1两种结果。

B错，因为一个指针企图修改一个const char*编译器是不允许的吧。

C没问题，c去读一个const char*，ch=‘c’。

D错，与A类似。我们希望得到的结果是01，但是由于不同编译器printf的入栈顺序有所差异，可能会得到00（先计算i--，再计算i++）的结果。

综上叙，E F不正确，由此得到C。


### 1.2e0.5错误

e后面必须为整数


### 循环

下面for语句执行时的循环次数为（）。

	int i, j;
	for ( i=0, j=5;i=j; )
	{ cout<<i<<j<< ndl; i++; j--; }

其中的条件是i，如果i等于0，循环结束，只有j等于0，i才会等于0。


### 内联函数

一般用于加快程序执行速度

可能减少可执行文件大小

可能增加可执行文件大小

首先 内联函数 本意就是为了提高程序运行速度所做的一项改进.但是它也可能使得程序运行变慢. 它可能使得可执行文件变小也可能使之变大.总之在使用不当都可能出现...



### strlen 和sizeof

定义char dog[]="wang\0miao";那么sizeof(dog)与strlen(dog)分别是多少：

sizeof返回数组所占的字节数，'wang' 'miao'共占8字节，显式'\0'占1字节，字符串末尾隐式'\0'占1字节，共10字节。

strlen返回字符串的长度，以遇到'\0'结束符为准，因此为4。

### 注意

	char a[3]; 
	a = "AB";

上述语法错误，a是一个常量地址，无法修改。而语句二将一个地址赋给一个常量地址，因此是错误的。

### 预处理命令

C语言有编辑、编译、执行三大过程。 C语言在编译前由预处理器对预处理命令进行处理，编译时进行语法分析。 执行过程就是运行程序。 


[C语言的预处理主要有三个方面的内容](https://baike.baidu.com/item/预处理命令/10204389?fr=aladdin)： 1.宏定义； 2.文件包含； 3.条件编译。 预处理命令以符号“#”开头。


### 运算符优先级

第一级别：  ::

第二级别： () []  ++（后自增）  --（后自减） -> .

第三级别： ！ not ~ ++（先自增） --(先自减)  -  * & 

第四级别： ->*

第五级别： * / % 

第六级别： + -

第七级别： << >>

第八级别： < <= > >=

第九级别： == eq != 

第十级别： & 

第十一级别： ^

第十二级别： | 

第十三级别：  &&

第十四级别： ||

第十五级别： : ?(条件运算符)

第十六级别： = += *= -= %= 

第十七级别： throw

第十八级别： ,（逗号分隔符）

### 不能被重载的运算符只有五个，分别是

1.  .  （成员访问运算符）
2.  *    （成员指针访问运算符）
3.  ::  （域运算符）
4.  sizeof  （长度运算符）
5. ?:    （条件运算符）

前两个运算符不能重载是为了保证访问成员的功能不被改变 ，域运算符和sizeof运算符的运算对象是类型而不是变量或者一般表达式，不具备重载的特征。

### 字节对齐

1. 某个变量存放的起始位置相对于结构的起始位置的偏移量是该变量字节数的整数倍；

2. 结构所占用的总字节数是结构种字节数最长的变量的字节数的整数倍。


一般情况，C++/C的变量所占字节数：


        char:    1字节；

        short:   2字节；

        int:       4字节；

        long:    4字节；

        long long: 8字节；

        float:    4字节；

        double: 8字节；

        bool:    1字节；


###  C/C++/C#/Java 都是严格区分大小写的计算机语言

### 多态

C++的多态性用一句话概括就是：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数

  1：用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。  

  2：存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。  

  3：多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。  

  4：多态用虚函数来实现，结合动态绑定.  

  5:纯虚函数是虚函数再加上 = 0；  

  6：抽象类是指包括至少一个纯虚函数的类。

纯虚函数:virtual void fun()=0;即抽象类！必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。



### C++源程序文件编译而成的目标文件的缺省扩展名为 .obj

编译生成.obj文件，链接后生成.exe


### 函数默认返回类型 int


你可以测试一下：

	abc()
	{
	}
	
	int i;
	i = abc();
	printf("%d",i);

如果abc（）是void，那么i = abc();一定会出错。如果编译程序不报错，那么说明这个函数是有返回值的。另外说一句，在C++中不允许函数的隐含类型

### 指针

现在有以下两个函数，调用test的结果是：不确定

	char* getMem(void) {     
	      char p[] = “hello world ”;
	       p[5] = 0x0;
	       return p;
	 }
	 void test(void) {     
	      char *s = 0x0;
	       s = getMem();
	       printf(s);
	 }


p是个数组，在{}里面定义是个局部变量，说明这个函数执行完毕之后局部变量销毁p这个数组中的值都没有了。

p虽然是个数组，但是单独用p这个变量，值是p这块数组的首地址，因为返回的是值传递，所以这个首地址被传到了下面的s中，s指向这个内存，而这个内存在getMem函数调用结束后就销毁了，里面存放的不知道是什么了。所以打印的话不一定出现什么。


### &a


以下代码的输出是（）

	int a[5]={1,2,3,4,5};
	int *ptr=(int*)(&a+1);
	printf("%d,%d",*(a+1),*(ptr-1));

答案是： 2， 5

这里有个特殊的地方，测试代码printf("%d\n",a); printf("%d\n",&a);这两个输出的地址是相同的，也就是&a是把数组看成一个整体，&a+1就是跳过数组的长度指向最后一个数字的下一个整型。*(ptr-1)就在再后退一个整型，也就是数组的最后一个元素。


### 格式化输出

使用printf函数打印一个double类型的数据，要求：输出为10进制，输出左对齐30个字符，4位精度。以下哪个选项是正确的？

	-： 左对齐
	30： 最小字段宽度
	.4： 精确度保留小数4位
	f： double精度浮点数
	e： 科学计数法

### 或和与的短路问题

设x、y、t均为int型变量，则执行语句：t=3; x=y=2; t=x++||++y; 后，变量t和y的值分别为____。

结果为： 1, 2

zt_xcyk
x++||++y执行后的结果是真，即1，然后赋值给t。因为是或运算，所以在判断x++时真后，后面的++y就不再执行了，所以y值没有变还是2

### define和typedef

test.c文件中包括如下语句：

	#define INT_PTR int*
	typedef int* int_ptr;
	INT_PTR a,b;
	int_ptr c,d;

文件中定义的四个变量中，哪个变量类型不是指针类型？


	#define INT_PTR int* 这是宏定义，编译预处理阶段要进行宏替换，INT_PTR a,b会变成 int * a,b 所以b不是指针类型
	typedef int* int_ptr; 这是自定义类型，也就是把int_ptr定义为 int型指针，编译阶段会把c,d都识别为指针


### 容器和类型

在C++STL中常用的容器和类型，下面哪些支持下标"[]"运算？

	vector
	list
	deque
	map
	set
	unordered_map
	unordered_set
	stack
	string

答案： vector、deque、map、unordered_map、string

- 标准 STL 序列容器： vector 、 string 、 deque 和 list 。   提供了快速访问元素的能力。
- 标准STL 关联容器： set 、 multiset 、 map 和 multimap 。 
- 非标准序列容器slist 和 rope 。 slist 是一个单向链表， rope 本质上是一 “ 重型 ”string 。 
- 非标准的关联容器hash_set 、 hase _multiset 、 hash _map 和 hash _multimap 。 
- 几种标准的非STL 容器，包括数组、 bitset 、 valarray 、 stack 、 queue 和 priority_queue 。


关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。

关联容器不支持顺序容器的位置相关的操作。原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值得操作。

关联容器支持高效的关键字查找和访问。两个主要的关联容器(associative container)类型是map和set。map中的元素是一些关键字----值(key--value)对：关键字起到索引的作用，值则表示与索引相关联的数据。set中每个元素只包含一个关键字：set支持高效的关键字查询操作----检查一个给定关键字是否在set中。


按关键字有序保存元素：set(关键字即值，即只保存关键字的容器)；multiset(关键字可重复出现的set)；

无序集合：unordered_set(用哈希函数组织的set)；unordered _multiset(哈希组织的set，关键字可以重复出现)。

set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的。

### 字符串和字符

	"" 表示字符串
	'' 表示字符

字符数组不能表示字符串： 	

	char str[] = {"a", "b"}; //错误


### STL

以下关于STL的描述中，____是错的。
正确答案: C  

	STL容器是线程不安全的
	当容量不够时，vector内部内存扩展方式是翻倍
	std::sort是稳定排序
	std::bitset不是一个STL容器
	std::stack默认是用deque实现的
	std::string中可以存储多个’\0’字符

A：“很多程序员希望STL实现是完全线程安全的“。所以不安全。

B：vector的存在可以使开发者不必关心内存的申请和释放。但是，vector的一个缺点就是它的内存分配是按照2的倍数分配内存的。

C：错误。要知道 std::sort 不是稳定的排序算法，它不保证“相等”元素的相对位置，使用 std::stable_sort 来保证这一点

D：STL的容器可以分为以下几个大类: 
一：序列容器，　有vector, list, deque, string.
二 : 关联容器,     有set, multiset, map, mulmap, hash_set, hash_map, hash_multiset, hash_multimap
三: 其他的杂项： stack, queue, valarray, bitset

E：正确。堆栈是一个线性表，插入删除操作都在一端进行，deque是先进先出的，操作原理和stack是一样的


### 析构函数

下面这段代码会打印出什么？

	class A
	{
	public:
	    A()
	    {
	        printf("A ");
	    }
	     
	    ~A()
	    {
	        printf("deA ");
	    }
	};
	 
	class B
	{
	public:
	    B()
	    {
	        printf("B ");
	    }
	    ~B()
	    {
	        printf("deB ");
	    }
	};
	 
	class C: public A, public B
	{
	public:
	    C()
	    {
	        printf("C ");
	    }
	    ~C()
	    {
	        printf("deC ");
	    }
	};
	int main()
	{
	    A *a = new C();
	    delete a;
	    return 0;
	}

正确答案: A  

	A B C deA
	C A B deA
	A B C deC
	C A B deC

如果按题中所说 加入virtual，那么输出的顺序是ABC deC deB deA。由于析构函数是虚函数，动态调用，那么会调用C的析构函数，由于C继承与A和B，所以先调用A B的析构，最后调用自己的。
如果A的析构函数不是虚函数，那么只会调用A的析构函数。

### 二维数组赋值

	int a[][2] = { 0 };
	int b[][2] = { { 1, 2 }, { 3, 4 } };
	int c[][2] = { { 1, 2,}, { 3, 4 }, {0} };
	都是可以的。
	但是int array[][2];不行
	int a[][3]={}; //正确

如果对全部元素都赋初值，则定义数组时第一维可以忽略，但是第二维必须存在。 同时：在定义的时候也可以对部分元素赋初值而忽略第一维的长度，但应该分行赋初值。

可见：可以忽略第一维的长度，但是是有条件的：要么你把全部元素都写出来，或者你分行写出元素（可以不全），但是不可以不赋值

### 构造函数调用顺序

建立派生类对象时,3种构造函数分别是a(基类的构造函数)、b(成员对象的构造函数)、c(派生类的构造函数)这3种构造函数的调用顺序为: 

	abc

先父母，再客人，后自己。

在继承中派生类的对象调用构造函数的顺序，应该是先调用基类的构造函数，然后是成员中的对象对应类的构造函数，最后是派生类自己的构造函数.

### 局部变量


在linux+gcc下,关于以下代码,正确的是()

	std::string& test_str()
	{
	   std::string str="test";
	   return str;
	}
	int main()
	{
	   std::string& str_ref=test_str();
	   std::cout<<str_ref<<std::endl;
	   return 0;
	}

编译警告、返回局部变量的引用，运行时出现未知错误、把代码里的&去掉之后，程序可以运行

返回局部变量引用或地址时，调用程序后，局部变量被销毁，所以会出现未知错误

引用返回的是局部变量本身，而不是复制一份再返回，所以结果难以预料；其次返回局部自动变量是可以的，只要不是地址或引用就可以，否则需要将变量声明成static类型。


### 字符转换

有如下程序段：

	char ch=-1;
	printf(“%02x,%02x”,ch,(unsigned char)ch);

则输出：

	ffffffff,ff

%02x表示输出最少2位，不足补0.

%x以十六进制无符号形式输出，-1转成二进制全是1，所以第一个输出8个f,第二个转换成unsigned char发生截断只有8位，所以输出ff

 %x 默认的输出大小就是4个字节

短数据类型扩展为长数据类型：①要扩展的数据类型为有符号类型，用短数据的符号位填充长数据多出来的高字节 ，-1 （11111111）扩展为int（方便转换为十六进制）即（符号位是1）11111111 11111111 11111111 11111111（ffffffff）②要扩展的数据类型为无符号的（unsigned char） ，用0来填充长数据类型的高字节，此时-1在内存的二进制存储（11111111 ）扩展为int即00000000 00000000 00000000 11111111（ff）。


### 静态成员函数

C++中规定，在建立对象前就可以为静态数据成员赋值。同时规定在静态成员函数中不能使用this指针；静态成员函数在类外定义时，不需要用static前缀；静态成员函数既可以在类内定义也可以在类外定义。

### 二维数组和指针

若有以下定义和赋值语句，则与&s[i][j]等价的是（）

	int s[2][3] = {0}, (*p)[3], i, j;
	p = s;
	i = j = 1;

答案：

	*(p+i)+j

	int (*p)[3] 表示一个指针，指向一个含有三个元素的数组；
	
	p=s，表示p指向了数组s的第一行，
	
	p+1 表示现在指针指向了数组s的第二行；
	
	*(p+1)表示数组s第二行第一个元素的地址；
	
	*(p+1)+1 表示数组s第二行第二个元素的地址；

### 与运算

求函数返回值，输入x=9999

	int func(int x){
	    int count=0;
	    while (x)
	    {
	        count++;
	        x=x&(x-1);//与运算
	    }
	    return count;
	}

一个数与这个数减1的结果进行'&'按位与运算，结果为：这个数二进制数最右边的1变为0；
举例说明如下：

	X=5；  
	5&（5-1） = 0101 & （0100） = 0100

经过上述计算，5的二进制最右边的1变为了0，由此可知，题目中count是用以统计x的二进制中1的个数的
9999的二进制表示为：10011100001111 共有8个1，显然，答案为8.


### 输出显示十六进制

hex: 表示十六进制

oct： 表示八进制

dec： 表示十进制

cout.setf(ios::hex);

或者

cout << hex << 100;


### C语言程序的组成

函数组成

注意主程序和主函数的区别，我把主程序理解为主函数了

### 与的截断

设a、b、c、d、m、n均为int型变量，且a=5、b=6、c=7、d=8、m=2、n=2,则逻辑表达式（m=a>b）&&(n=c>d)运算后，n的值为：

	2

由于m=a>b的值为零，所以，表达式为假，&&后半部分不会操作，因此n为初始值2

### 初始化地址

	int* pint = 0; 
	pint += 6; 
	cout << pint << endl;

以上程序的运行结果是： 24

两个点：

1.在初始化中只有地址才能赋值给指针，因此*int p=0是指p指向地址0x00。

2.int型数占4个字节，因此加6表示偏移了24个字节，结果的地址应为0x18，即是24.

0x18转换成十进制为24


### 数组与指针的区别

下列关于数组与指针的区别描述正确的是？


正确答案: B  

	数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。
	用运算符sizeof 可以计算出数组的容量（字节数）
	指针可以随时指向任意类型的内存块。
	用运算符sizeof 可以计算出指针所指向内容的容量（字节数）


A.堆上创建动态数组

B.sizeof(数组名)就是数组的容量

C.const指针不可以

D. char* str = "hello"; sizeof(str)不能计算出内容的容量，只是指针的容量。


### 数组名

数组名为指针常量，不能更改

	char str[80];
	str = "abcedf";

上述代码是错误的。

### 字符数组

以下程序的输出结果是?

	#include <stdio.h>
	main()
	{
	  char a[10]={ ‘1’,‘2’,‘3’,‘4’,‘5’,‘6’,‘7’,‘8’,‘9’,0},*p;
	  int i;
	  i=8;
	  p=a+i;
	  printf("%s\n",p-3);
	}

输出为： 6789

因为输出%s,结果是6789;

如果输出%c,结果是6；

参数是头地址时，会把剩下的全部输出！！！！ *p,传参，参数是首地址，所以会把剩下的全部输出

### 析构函数调用顺序

下面程序的运行结果为（        ）

	#include <iostream>
	using namespace std；
	class A{
	public：A(){cout<<"1";}
	~A(){cout<<"2";1}
	};
	class B:public A{
	public:B(){cout<<"3";}
	~B(){cout<<"4";}
	};
	void main(){B b;}

输出： 1342


在C++中：

（1）对于构造函数，先调用基类的构造函数，再调用派生类的构造函数，就像盖楼房一样，从地基开始，一层两层往上盖。。
     
（2）对于析构函数，先是调用派生类的析构函数，再调用基类的析构函数，就像拆楼房一样，从上面开始拆。。。
   
注：先构造的后析构。

实例化子类对象构造函数调用顺序：父类，成员对象，子类；

析构顺序：子类，成员对象，父类。


### 全局变量和局部变量

下面程序会输出什么：

	static int a=1;
	void fun1(void)
	{
	    a=2;
	}
	void fun2(void)
	{
	    int a=3;
	}
	void fun3(void)
	{
	    static int a=4;
	}
	int main()
	{
	  printf(“%d”,a);
	  fun1( );
	  printf(“%d”,a);
	  fun2( );
	  printf(“%d”，a）；   
	  fun3( )
	  printf(“%d”,a); 
	}

答案：

	1 2 2 2


首先声明了一个静态全局变量i，首次输出我就不说了，妥妥的1。第二次输出，访问到了早已定义的全局变量i，并改写值，第二次为2。第三次输出，内部定义了一个同名的变量， 它并没有返回值或者被该次执行程序以外任何程序读取a值，所以第三次输出仍然是a。第四次输出，定义了一个静态的局部变量，静态局部变量在函数调用结束后仍然存在，及它的内存空间不会被释放，但其他函数是不能引用它的，所以，两个静态变量虽然同名，但是并不是一样的东西，为2。

### 虚函数

![](https://uploadfiles.nowcoder.com/images/20170809/4155837_1502268982824_583B0E3AECF1C1D9AF11E0919965FDBA)

以上程序中，下列哪个函数调用会有问题（）

	b->FunctionB();


因为虚函数本质上是通过类对象的虚表进行访问，而且类的成员函数除了虚函数，其他都不存储在类当中，因此类对象不存在的情况下，无法使用虚函数，其他函数都可以正常访问（前提是这些函数都没有存取类对象的成员变量）


### 类声明

如果MyClass为一个类，执行”MyClass a[5], *b[6]”语言会自动调用该类构造函数的次数是()

	5

MyClass a[5]，会创建5个对象，所以会自动调用5次构造函数，但是MyClass *b[6],这不会自动调用构造函数，因为这是声明一个指向6个元素的数组的指针，指针声明的时候是不分配空间的，所以不会调用构造函数，没有指向一个有效的内存空间。

MyClass *b[6]表示一个指针数组，数组里面存放的是指向MyClass类型的指针，即存放的地址，故不会调用该类的构造函数；
MyClass (*p)[6]表示一个数组指针，也不会调用该类的构造函数；

### 数组指针和指针数组


数组指针（也称行指针）

	定义 int (*p)[n];

()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。


如要将二维数组赋给一指针，应这样赋值：

	int a[3][4];
	int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。
	 p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]
	 p++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]

指针数组	

	定义 int *p[n];

[]优先级高，先与p结合成为一个数组，再由int$\ast$说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素，这样赋值是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]...p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 *p=a; 这里*p表示指针数组第一个元素的值，a的首地址的值。
如要将二维数组赋给一指针数组:

	int *p[3];
	int a[3][4];
	p++; //该语句表示p数组指向下一个数组元素。注：此数组每一个元素都是一个指针
	for(i=0;i<3;i++)
	p[i]=a[i]

这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]
所以要分别赋值。

### 运算符重载

重载之后的运算符不能改变运算符的优先级和结合性，也不能改变运算符操作数的个数及语法结构。

运算符重载不能改变该运算符用于内部类型对象的含义。

### 指向常量的指针和指向常量的应用

	const int * p1;

x是指向常量的指针，指针指向一个常量，无需初始化，指针本身可以改变，但是指针指向的值不能改变。

如：

	const int x=10;
	const int *p1=&x;
	p1++;//ok
	(*p1)++;//error

指向常量的引用

	const int & x;

const int &i是指向常量的引用，使用时必须初始化，而且初始化后，引用值不可以改变,引用的常量也不能改变。
如：

	const int &p2;//error
	const int &p2=x;//ok
	const int y=20;
	p2=y;//error
	p2++;//error


int const & x和const int & x效果相同。

对于指针来说, const出现在*号的左边还是右边或是左右都有才有区别, 具体的:

	const type *p; // 一个不能修改其指向对象的type型指针
	// 其实和type const *p等效
	type * const p; // 一个不能修改其自身指向位置的type型指针
	const type * const p;
	// 一个既不能修改其指向对象也不能修改其自身指向位置的type型指针


对于除指针以外的其他常量声明句法来说，

	const type name
	和
	type const name

的效果是相同的, 即都声明一个类型为type名为name的常量，如:

	const int x = 1;
	和
	int const x = 1;
	还有
	int x = 1;
	const int &y = x;
	和
	int const &y = x;

都是等效的, 只是写法的风格不同而已,


### (int)x, (int &)x, (int*) x的区别

- (int)x 强制类型转换，是将浮点数x为参数构造整数（即float转换为int）
- (int &)y 则是告诉编译器将y看成int对待（内存里的数据不做任何转换)
- (int*)就是强制转换成整型指针，一般人们容易混淆的是(int)和(int&)这两个。

![](http://pp0km9u5d.bkt.clouddn.com/~IG%29SSU1TPU6N%7B09NHA9%7DDJ.png)

对于(int &)x，是直接将存储的二进制转换为int。所以(int &)x的值是1071 644 672，即将0011 1111 1110 0000 0000 0000 0000转化为二进制。

### auto和decltype类型声明

	int i=0;
	const int ci=i;
	auto b=ci; //(1)
	int *p=&i;
	decltype(*p) c=i;//(2)

以上（1）（2）中变量b，c类型为： int, int&

- (1) auto会忽略顶层const，所以b的类型为int
- (2) 如果表达式的内容是解引用操作，则decltype将得到引用类型



### 字符串输出

printf 函数中用到格式符%5s，其中数字5表示输出的字符串占用5列，如果字符串长度大于5，则输出按方式（）。

按原字符长从左向右全部输出

分情况看待：

- 1：字符串长度比设定长度大就按字符串实际长度输出；
- 2：字符串长度比设定长度小就按右对齐输出该字串,左补空格。


### 内存中声明类对象的数量

假定Qiniuome是一个类，执行下面这些语句之后，内存里创建了几个Qiniuome对象。

	Qiniuome a();
	Qiniuome b(2);
	Qiniuome c[3];
	Qiniuome &ra = b;
	Qiniuome *pA = c;
	Qiniuome *p = new Qiniuome(4);

答案是： 5
	
	CSomething a();//只是定义一个方法，方法返回一个CSomething对象
	CSomething b（2）;//增加1个对象
	CSomething c[3];//对象数组，增加3个对象
	CSomething &ra=b;//引用不增加对象
	 
	CSomething *pA=c;//地址赋值，不增加对象
	CSomething *p=new CSomething;//在堆上构造一个对象，增加1个对象
	 

所以最后一共有： 1+3+1 =5个对象。

需要注意的是a()是一个函数声明。

### switch注意点

- default的位置可以位于开头
- case的值必须为常量, 例如 case: 1，而case : a是错误的
- switch后面必须有括号，例如switch(a * b)


### 时间复杂度

以下程序是用辗转相除法来计算两个非负数之间的最大公约数：

	long long gcd(long long x, long long y) {
	    if (y == 0)
	        return x;
	    else
	        return gcd(y, x % y);
	}

我们假设x,y中最大的那个数的长度为n，x>y，基本运算时间复杂度为O(1)，那么该程序的时间复杂度为（ ）

o(logy)

时间复杂度和较大数的长度没有关系，假设x为较大数，不论它有多大，y为一个特别小的数字，比如2，那么它的运算次数很小很小，和x就没有关系，反而运算次数会受到y的限制

### 内联

内联可能会寻致二进制可执行文件尺寸变大吗？

不会

假设系统有100个内联函数，每个展开后有100字节，并且被调用了100次。这就会增加1MB的大小 

### 静态函数

编译运行如下程序会出现什么结果

    #include <iostream>
	using namespace std;
	 
	class A
	{
	    A()
	    {
	        printf("A()");
	    }
	public:
	    static A &get()
	    {
	        static A a;
	        return a;
	    }
	};
	int main()
	{
	    A::get();
	    return 0;
	}

输出A()


调用静态函数本身不会执行构造函数， 但 get ()实例化了一个对象，所以在get（）里面调用了构造函数。这个代码考察的是单例模式，其中构造函数是私有函数。要想获得A的对象只能通过get()函数。


### 虚函数

以下程序的输出是

	class Base {
	    public:
	    Base(int j): i(j)  {}
	    virtual~Base() {}
	    void func1() {
	        i *= 10;
	        func2();
	    }
	    int getValue() {
	        return  i;
	    }
	    protected:
	    virtual void func2() {
	        i++;
	    }
	    protected:
	    int i;
	};
	class Child: public Base {
	    public:
	    Child(int j): Base(j) {}
	    void func1() {
	        i *= 100;
	        func2();
	    }
	    protected:
	    void func2() {
	        i += 2;
	    }
	};
	int main() {
	    Base * pb = new Child(1);
	    pb->func1();
	    cout << pb->getValue() << endl; delete pb; }

Base * pb = new Child(1)， 首先创建子类对象，初始化为1；
func1()不是虚函数，所以pb->func1()执行的是基类的func1函数，i= 10，然后调用func2()函数；
这里的func2是虚函数，要往下派生类寻找，找到后执行派生类中的func2(),此时，i = 12；
最后执行pb->getValue(),结果为12


### 只能使用new创建对象

在C++中，为了让某个类只能通过new来创建（即如果直接创建对象，编译器将报错），应该（）

通过将析构函数设为私有

原因：编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。 因此， 将析构函数设为私有，类对象就无法建立在栈（静态）上了，只能在堆上（动态new）分配类对象 。

编译器在栈上创建对象时，如果类的析构函数是私有的，则无法回收栈上的内存。因此无法在栈上创建。

通过new创建对象，但是无法通过delete删除对象，需要提供额外的destroy()函数


### 取余

若变量已正确赋值，下列哪些表达式不符合C的语法？

正确答案: C D  
 
	A a=a+7
	B a=7+b+c,a++
	C int（12.3%4）
	D a=a+7=c+b

C选项中，取余操作（%）必须是针对整数来操作，所以是错误的。

D选项中，赋值操作（=）操作，是典型的右结合的，但是在辅助操作符左边，要求必须是变量，在本题中7是常量，所以会报错。
以上代码都在vs2012中验算过。

### C语言源程序的最小单位是： 字符

程序行、语句、函数都是由字符构成的，字符是C语言的最小单位。

### 栈

设栈的顺序存储空间为S（1：m），初始状态为top=m+1。现经过一系列正常的入栈与退栈操作后，top=0，则栈中的元素个数为（）

答案是： 不可能

栈的顺序存储空间是S（1：m），初始状态top = m + 1，栈装爆了top = 1，不可能 = 0，所以答案是不可能...

### 字符串变量

C++语言不能定义字符串变量，是对的

对于C与C++来说是没有字符串这种数据类型的，只是可以通过字符数组或者指向字符的指针又或者C++的标准库string来实现存储字符串，但是这并不能称作定义了字符串变量

### 链表节点

为了建立如图所示的存储结构(即每个结点含两个域,data是数据域,next是指向结点的指针域),则在[] 处应填入选项是

struct link 
{ 
    char data;
    []; 
} node;

正确答案: B 

	link next;
	struct link * next;
	link * next;
	struct link next;

在C++中B、C都行，但在C中只有B行。因为在C++中可以有不完全的类类型，就是在类中可以声明类自身的指针和引用。


### 字符数组和指针

运行以下C语言代码，输出的结果是( )

	#include <stdio.h>
	int main()
	{
	    char *str[3] ={"stra", "strb", "strc"};
	    char *p =str[0];
	    int i = 0;
	    while(i < 3)
	    {
	        printf("%s",p++);
	        i++;
	    }
	    return 0;
	}


答案： stra tra ra

- 1，p是char*类型，每次++，后移一位（char）
- 2，char *p=str[0]相当于char *p="stra"，p先指向s，p++后，指向t
- 3，printf输出遇到空字符停止


### 转义字符

以下程序段的输出结果是

	char s[]="\\123456\123456\t";
	printf("%d\n",strlen(s));

答案: 12

这里考查转义字符，注意 \\ 表示字符 \
- \123表示字符 {
- \t 表示制表符
- 这些都是一个字符。

ascii码中，‘\ddd’表示八进制，'\xdd'表示十六进制，（d是一位数字占位符，x是十六进制标志），因为‘\’后边没有‘x’，所以解释为三位八进制'\123'，其十进制是83，在ascii中是‘S’。


### C语言中指针的说法错误的是：

正确答案: B C   

	A 指针的值是一个地址
	B 非法指针是指该指针的值不是一个已经分配的内存地址
	C 两个指向同类型地址的指针之间做减法一般是没有意义的
	D 指针的指针占用的内存空间和其他指针占用的内存空间相同

非法指针： 非法指针并不只是未分配的内存，而包括所有已经不能访问的内存，例如，指向已经返回的函数局部变量，越过数组边界的地址等。

同类型指针相减： 两个同类型指针相减有意义，这就是求差，但相加没有意义。

比如，两个数组元素一一对应，当我们已知A的X元素，而要找B中与之对应的Y时，就可以使用。
B + (X - A) 其中X - A就是同类型指针相减，这是有效也是唯一的作法。


### const修饰成员函数

 在类成员函数的声明和定义中，

const的函数不能对其数据成员进行修改操作。

const的对象，不能引用非const的成员函数。

	#include <iostream>
	using namespace std;
	
	class aa{
	    int num;
	public:
	    aa(){
	        int b =10;
	        num = b;
	    };
	    void out1(){
	        cout<<num<<endl;
	    }
	    void out2() const{
	        cout<<num<<endl;
	    }
	    void out3() const{
	        num+=10; //出错，const函数不能修改其数据成员
	        cout<<num<<endl;
	    }
	
	};
	int _tmain(int argc, _TCHAR* argv[])
	{
	    aa a1;
	    a1.out1();
	    a1.out2();
	    a1.out3();
	    const aa a2; //const对象
	    a2.out1(); // 错误，const的成员 不能访问非const的函数
	    a2.out2();
	    a2.out3();
	    return 0;
}


### scanf
	
	main()
	{  
	int  m,n,p;
	   
	scanf("m=%dn=%dp=%d",&m,&n,&p);
	   
	printf("%d%d%d\n",m,n,p);
	}

若想从键盘上输入数据,使变量m中的值为123,n中的值为456,p中的值为789,则正确的输入是(      )   。

scanf函数完全就是字符串匹配而已啦。
如果你这么写，scanf("%d %d %d",&m,&n,&p);那么输入就应该是123 456 789；
如果写成scanf("%d,%d,%d",&m,&n,&p);那么输入就应该是123,456,789。
字符串一个一个的匹配，匹配到%d时，就自动把数值赋给右边的参数..


### const

c++中，声明const int i,是在哪个阶段做到 i只可读的？

编译

const用来说明所定义的变量是只读的。 这些在编译期间完成，编译器可能使用常数直接替换掉对此变量的引用。



### 函数调用

以下关于函数调用的说法哪个是正确的？

正确答案: D 

	传值后对形参的修改会改变实参的值
	传地址后实参和形参指向不同的对象
	传引用后形参和实参是不同的对象
	以上都不对

- 值传递：形参和实参占用不同的内存空间，传递的时候形参相当于一个副本，存储在另一个地址，有两个空间保存变量值（变量值相等），所以修改形参不会改变实参的值，因为根本没改变实参空间内的值。
- 传地址：形参和实参都是一个相同的地址，指向相同的内存空间，该空间保存变量值，所以在地址传递时可以通过地址访问改变实参变量值。
- 传引用：引用相当于一个别名，跟人的外号一样，指向的都是同一个人，传引用的时候虽然形式看起来跟值传递一样，但是它并不会复制一个副本进行变量保存，即只有一个空间保存变量值。

指针传递参数本质上是值传递的方式，它所传递的是一个__地址值__。


### 程序错误分析

指出下面程序哪里可能有问题？

	class CBuffer
	{
	    char * m_pBuffer;
	    int m_size;
	    public:
	        CBuffer()
	        {
	            m_pBuffer=NULL;
	        }
	        ~CBuffer()
	        {
	            Free();
	        }
	        void Allocte(int size) （1） {
	            m_size=size;
	            m_pBuffer= new char[size];
	    }
	    private:
	        void Free()
	        {
	            if(m_pBuffer!=NULL) (2)
	            {
	                delete[] m_pBuffer;
	                m_pBuffer=NULL;
	            }
	        }
	    public:
	        void SaveString(const char* pText) const (3)
	        {
	            strcpy(m_pBuffer, pText); (4)
	        }
	        char* GetBuffer() const
	        {
	            return m_pBuffer;
	 
	    }
	 
	    };
	 
	void main (int argc, char* argv[])
	{
	    CBuffer buffer1;
	    buffer1.SaveString("Microsoft");
	    printf(buffer1.GetBuffer());
	}


错误： (1) (3) (4)

(1) 分配内存时, 未检测m_pBuffer是否为空, 容易造成内存泄露;

(3) (4) 处修改如下：

	void
	SaveString(const char* pText)（1）
	{
	Allocte(strlen(pText)+1);（2）
	strcpy(m_pBuffer,
	pText);
	}

- const 成员函数不能修改数据成员，所以必须去掉const
- m_pBufer开始指向NULL，必须向用Allocate分配内存才能赋值。

### 递归时间复杂度

	void recursive(int n, int m, int o)
	{
	    if (n <= 0)
	    {
	        printf("%d,%d\n", m, o);
	    }
	    else
	    {
	        recursive(n - 1, m + 1, o);
	        recursive(n - 1, m, o + 1);
	    }
	}

以上函数的时间复杂度（）

o(2^n)

n会递归两次n-1
n-1会递归两次n-2
n-2会递归两次n-3

所以，是一个完全二叉树，总共是2^n-1次，时间复杂度O(2^n)

递推公式
	
	T(n) = 2 * T(n-1)
	T(n) = 2 * ( 2 * (T(n-2) ) ) = ... = 2^n * T(1)
	
	T(1)  = O(1)
	T(n) = O(2^n)

### \0内存表示

C语言字符串以\0结束，\0在内存中的表示为（）?

在内存中实际表示为0

‘\0’ 是 c/c++ 语言中的字符串结束符，在ASCII字符集中对应空字符NULL，数值为0。其作用是识别字符串，简化字符串处理过程。在使用过程中要为其分配内存空间，但不计入字符串长度。

### 字符数组和指针

针对以下代码，

	const char str1[] = "abc";
	const char str2[] = "abc";
	const char *p1 = "abc";
	const char *p2 = "abc";

判断下列说法哪个是正确的（）

str1和str2地址不同，P1和P2指向的地址相同

str1和str2是栈空间中的两个字符数组，地址不同

p1和p2指向的位置在常量区，值都是“abc”所以是同一常量，地址相同

#### 字符常量

以下叙述中正确的是（）

正确答案: B   

	字符串常量"Hello"会被隐含处理成一个无名字符型数组，它有5个元素
	不能用字符串常量对字符数组名进行整体赋值操作
	char str[7] = "string!"; 在语法上是合法的，运行也是安全的
	char *str; str = "Hello";与char str[]; str = "Hello";效果是一样的

初始化和赋值是不同的概念

	char a[] = "abc"; //正确
	char a[10];
	a = "abc"; //错误

可以使用字符常量初始化字符数组名，但是不能给字符数组赋值。

字符串中的字符依次存储在内存中一块连续的区域内，并且把空字符 ' \0' 自动附加到字符串的尾部作为字符串的结束标志。故字符个数为 n 的字符串在内存中应占（ n+1 ）个字节。选项 A 中有 6 个元素，其中包含结尾字符， C 选项中字符串常量包含 8 个字符，所以不能赋值在 str[7] 中， D 选项后者赋值错误。

### 结构体内存`对齐


有以下代码：

	struct A
	{
	    bool b;
	    int arr[2];
	    int i;
	    int j;
	};
	int main()
	{
	    A a;
	    a.b = false;
	    a.arr[0] = 1;
	    a.arr[1] = 2;
	    a.i = 20;
	    a.j = 30;
	    *(a.arr + 1) = 40;
	    A*p = 0;
	    unsigned int q = (unsigned int)(&p->i));
	    (*(int*)((char*)&a +q)) = -50;
	     return 0;
	}

当main函数返回之前，请问以下哪些说法是错误的：（    ）

正确答案: C   

	a.b的值是false
	arr[0]的值是1
	a.i的值是20
	a.j的值是30

根据地址对齐原则，i的起始地址为12。bool占一个字节，int arr[0]一个字节，这样bool需要填充3个字节，使得其实int arr[0]的倍数。然后int arr[1]占4个字节，所以一共是12个字节。

p的地址为0，那么&p->i的地址为12，相当于i相对于结构体头地址的偏移量为12个字节，(char*)&a +q自然就指向的a中i的地址，i被修改为-50

### 数组指针和指针数组

在64位系统下，分别定义如下两个变量：`char *p[10]; char(*p1)[10];`请问，sizeof(p)和sizeof (p1)分别值为____

答案： 80， 8

数组指针：  char (*p1)[10]，p1是一个指向存放10个char类型的数组的指针，所以sizeof(p1)等于8。

指针数组: char *p[10], 数组中存放了10个指针，在64位系统中指针占8个字节，所以sizeof(p)等于80。

`char *p[10]`，p与[]结合，所以p就是一个数组，数组的元素比较特殊，是指针，指针大小为8，所以是10*8=80；

`char(*p1)[10]`，与*结合，所以是一个指针，大小为8


![](http://wbingeek.qiniudn.com/2csapp2.png)


### 隐含存储类别

在C语言中，函数的隐含存储类别是（）。

正确答案: C  

	auto
	static
	extern
	无存储类别

如果在函数定义中没有说明extern或static，则隐含为extern。从这道题也可以认识到，以后在C文件中写函数时，假如该函数不是给其他文件调用，要加上static修饰！

### 类知识点

下述有关c++的虚类和java接口的描述，说法错误的是？

正确答案: C D   你的答案: A B D (错误)

	c++虚类相当与java里面的抽象类
	c++中没有接口的概念，与之对应的是纯虚类，对应的是java的接口
	纯虚函数和虚函数的区别在于前者只包含定义，而后者还可以包含函数体。
	一个抽象类和接口中的方法必须是抽象方法


抽象类 ： 类中至少有一个方法是抽象方法，则该类就是抽象类

接口 ：类中的方法全部都是抽象方法。

链接：https://www.nowcoder.com/questionTerminal/6027723bb7f945339125f20d183138fe
来源：牛客网

纯虚函数可以有函数体 C++ primer 5th p541。但是函数体只能定义在类外，例如：

	class A{
    public:
	       virtual void func() = 0;
	};
	void A::func(){
	     cout<<"func"<<endl;
	}

所以C是错误的。 

c++虚类，即抽象类，至少有一个抽象方法，可以有方法定义

java接口，都是抽象方法，对应c++纯虚类


### 引用

引用可以是void类型吗？

不可以

void类型没有分配内存，而引用必须是另一个固定内存变量的别名，所以不能指向void

### 内存对齐


已知职工记录描述如下，在Turbo C中，系统为变量w分配（ ）字节的空间。

	struct worker
	
	{  int no;
	
	char name[20];
	
	char sex;
	
	union
	
	{ int day;  int month;  int year;}birth;
	
	} w;

答案是： 25

Turbo C中int占2个字节

2 + 1*20 + 1 + 2 = 25

分别是no的字节大小,name[20]的字节大小,sex的字节大小,然后是联合体birth的大小,

联合体是个省内存的定义方法,里面的day month year被定义在一个2字节大小的空间中,它是day 还是month 还是year,完全取决于编程人员最后一次对它的引用.


### 指针函数和函数指针

指针函数是指带指针的函数，即本质是一个函数，并且返回类型是某一类型的指针
定义：  返回类型标识符 *函数名称（形参表）{函数体}

函数指针是指向函数的指针变量，即本质是一个指针变量。


### 类模板

模板类的继承包括四种：

- 1.（普通类继承 模板类 ）
- 2.（类模板继承了普通类（非常常见））
- 3.（类模板继承类模板）
- 4.（类模板继承 模板类，即继承模板参数给出的基类）


根据建立对象时的实际数据类型，编译器把类模板实例化为模板类。

### 只能初始化不能赋值的情况

- 类中的const成员遍历
- 基类无默认构造函数，有参数的构造函数都需要初始化
- 类中含有引用成员变量

因为const对象以及引用只能初始化而不能赋值，所以只能使用成员初始化列表。

对于非内置类型，在进入函数体之前，如果没有提供显式初始化，会调用默认构造函数进行初始化。若没有默认构造函数，则编译器尝试调用默认构造函数将会失败，所以如果没有默认构造函数，则必须在初始化列表中显示的调用构造函数。

static 成员在执行构造函数前就已经构造好了，即使不存在类对象，也可以被使用，不需要初始化列表。

如果父类中没有默认构造方法，那么，在子类中的初始化列表中必须显式的调用基类的有参数构造，否则会编译不通过
	
	class testA
	{
	private:
	    int val;
	public:
	    //testA(int x):val(x){}//编译通过
	    testA(int x){val = x;}//编译通过
	    testA()=delete;
	};
	
	class testAA : public testA
	{
	private:
	    int val2;
	public:
	    //testAA(int x):val2(x){}//编译不通过
	    testAA(int x):val2(x),testA(x){}//编译通过
	    testAA(int x, int y) : testA(y){val2 = x;}//编译通过
	    //testAA(int x, int y) : val2(x), testA(y){}//编译通过
	    testAA()=delete;
	};


### 堆和栈内存

对于函数中以下代码，

	char* p=new char[100];

P在栈上，new出来的在堆上

### 赋值


以下不符合 C 语言语法的赋值语句是（）。
正确答案: D   

	j++;
	j=j=5;
	k=2*4,k*4;
	int y=float(j);

强制类型转换格式： int y = (float)j;

C语言强制类型转换一般形式为：（类型说明符）（表达式）
类型说明符和表达式都必须加括号（单个变量可以不加括号），例如： (float) a 把a转换为浮点型，(int)(x+y) 把x+y的结果转换为整型。


### 类中static和const


Fill the blanks inside class definition
	
	class Test
	{
	    public:
	        ____ int a;
	        ____ int b;
	    public:
	        Test::Test(int _a , int _b) : a( _a )
	        {
	             b = _b;
	        }
	};
	int Test::b;
	int main(void)
	{
	    Test t1(0 , 0) , t2(1 , 1);
	    t1.b = 10;
	    t2.b = 20;
	    printf("%u %u %u %u",t1.a , t1.b , t2.a , t2.b);
	    return 0;
	}

Running result : 0 20 1 20

正确答案：

	const/static
	或
	--/static


对于成员变量a，若它为const类型，那么必须要使用Test::Test(int _a , int _b) : a( _a )这种初始化形式，若它为普通成员变量，也可以采取Test::Test(int _a , int _b) : a( _a )这种形式，所以a可以为const或者普通类型，由于b没有采取Test::Test(int _a , int _b) : b( _b )这种形式，所以b一定不是const类型，有main()中的t1.b和t2.b的输出都是20可以知道，b是静态变量。


### 指针常量和常量指针

下面对应正确的是:

	正确答案: A B C   你的答案: A B C D E (错误)

	const int a; //const integer
	int const a; //const integer
	int const *a; //a pointer which point to const integer
	const int *a; //a const pointer which point to integer
	int const *a; // a const pointer which point to integer

对于A和B，int const 和 const int 可以颠倒位置，意义不变，CDE都表示指向const int 的指针，而int *const a 才表示指向int的const指针

const pointer（常量指针）： 星号必须在const的前面，例如`int * const p;`

指针常量：指针的值不能变，指针本身是常量

常量指针：指针指向的值不能变

b是一个常量

	const int b;  /* b is a int const */
	int const b;  /* b is a const int */

p是一个常量指针，指向一个常量

	const int *p; /* p is a pointer to int const */
	int const *p; /* p is a pointer to const int */

p是一个指针常量，指向一个普通变量

	int *const p;  /* p is a const pointer to int */

p是一个指向常量的指针常量

	const int *const p;  /* p is a const pointer to int const */
	int const *const p;  /* p is a const pointer to const int */


### &数组名

以下代码的输出是（）

	int a[5]={1,2,3,4,5};
	int *ptr=(int*)(&a+1);
	printf("%d,%d",*(a+1),*(ptr-1));

答案： 2，5

数组名是一个指针常量，也就是数组第一个元素的地址。*(a+1)= a[1] = 2

&a代表的int[]$\ast$每次步长所指向的数组的大小，&a把数组看成一个整体，&a+1指向数组最后一个元素的下一个位置，所以`*(ptr-1)`表示最后一个元素。

C/C++里面的数组名字会退化为指针，所以数组名a实际指的是数组的第一个元素的地址。而数组名作为指针来讲有特殊性，它正在它所指向的内存区域中，&a的值和a的数值是相同的（可以输出观察一下），但是类型和意义不同。而指针的加法操作和指向的数据类型密切相关。
比如：
int a[10]; a就相当于int$\ast$，如果是对它加1（a + 1）是相当于a + 1 $\ast$ sizeof(int)。但是&a的类型则相当于int $\ast$$\ast$，是所谓指向数组的指针，是数组元素类型的二级指针，对它加1是相当于 &a + 1 $\ast$ sizeof(a)的，所以会偏移一个数组长度。

### 动态绑定

()是面向对象程序设计语言中的一种机制。这种机制实现了方法的定义与具体的对象无关，而对方法的调用则可以关联于具体的对象。

答案是： 动态绑定

面向对象有三种特性：封装，继承，多态

其中多态性有两种，一种是依靠函数重载实现的静态绑定，一种是依靠虚函数实现的动态绑定。动态绑定跟对象的引用类型无关，他会根据具体的对象调用对应的方法。


### memset

阅读以下代码：

	class parent  
	{  
	    public:  
	    virtual void output();  
	};  
	void parent::output()  
	{  
	    printf("parent!");  
	}  
	       
	class son : public parent  
	{  
	    public:  
	    virtual void output();  
	};  
	void son::output()  
	{  
	    printf("son!");  
	}
	
	son s; 
	memset(&s , 0 , sizeof(s)); 
	parent& p = s; 
	p.output(); 

 执行结果是（）

没有输出结果，程序运行出错

void $\ast$ memset(void $\ast$s, int ch, size_t n);
  
函数解释：将s中前n个字节 （typedef unsigned int size_t ）用ch替换并返回s.
作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法,通常为新申请的内存做初始化工作.

### 数组定义

	int a[n];

n必须为常量。

	int n = 5; //错误
	const int n = 5; //正确
	#define n = 5  //正确
	enum {n = 5};

### 柔性数组

柔性数组（flexible array），柔性数组是指声明长度为0的数组，用sizeof运算符计算出来的长度为0。

柔性数组有很多表现形式：

    //uni-dimensional
    int a[0]; //等同于int a[] = {};
    //multi-dimensional
    int a[0][5]; //等同于 int a[][5] = {};
    //involved in a struct
    struct s {
        int a[0]; //等同于 int a[];
    };

### 转义字符

以下程序段的执行结果是（）。

	double  x;x=218.82631;
	printf("%-6.2e\n",x);

输出为2.19e+02

- %：表示格式说明的起始符号，也是转义符号，有一题 printf（“%%%%”）输出几个？答案输出%% 两个
- -：有-表示左对齐输出，如省略表示右对齐输出 
- 0：有0表示指定空位填0,如省略表示指定空位不填 
- m.n m指域宽，即对应的输出项在输出设备上所占的字符数。 n指精度。用于说明输出的实型数的小数位数。没有指定n时，隐含的精度为n=6位 
- e格式表示以指数形式输出实数

那么这题的意思是以左对齐、指数形式、总长度m =6、小数n=2两位 输出 


### 负数的余数

若有一下程序


	#include<stdio.h>
	main(){
	    int b=10,a=－11;
	    a%=b%=4;
	    printf("%d %d\n",a,b);
	｝

则程序的输出结果是？

－1 2

先计算b%=4,即b=b%4,结果为2,然后计算a%=2.结果为－1,最后a的值为－1,b的值为2

取余的函数定义 a%b = a - (a/b)*b

C+ + 中余数符号与被除数的符号一致   a / b， 其中a是被除数，b是除数，所以余数的符号跟a一致


### 回调函数

下面有关回调函数的说法，错误的是？
正确答案: C  

	回调函数就是一个通过函数指针调用的函数
	回调函数可能被系统API调用一次，也可能被循环调用多次
	回调函数本身可以是全局函数 ，静态函数和某个特定的类的成员函数
	回调函数可用于通知机制

回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方法直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。

回调函数还真有点像BP机：告诉别人号码，在它有事情时Call您
 
回调用于层间协作，上层将本层函数安装在下层，这个函数就是回调，而下层在一定条件下触发回调，例如作为一个驱动，是一个底层，他在收到一个数据时，除了完成本层的处理工作外，还将进行回调，将这个数据交给上层应用层来做进一步处理，这在分层的数据通信中很普遍。 

其实回调和API非常接近，他们的共性都是跨层调用的函数。但区别是API是低层提供给高层的调用，一般这个函数对高层都是已知的；而回调正好相反，他是高层提供给底层的调用，对于低层他是未知的，必须由高层进行安装，这个安装函数其实就是一个低层提供的API，安装后低层不知道这个回调的名字，但它通过一个函数指针来保存这个回调，在需要调用时，只需引用这个函数指针和相关的参数指针。

其实：回调就是该函数写在高层，低层通过一个函数指针保存这个函数，在某个事件的触发下，低层通过该函数指针调用高层那个函数。


### 64位系统

64位系统下地址位8个字节

	struct T {
	    char a;
	    int *d;
	    int b;
	    int c:16;
	    double e;
	};
	T *p;

在64位系统以及64位编译器下，以下描述正确的是：

正确答案: C  

	sizeof(p) == 24
	sizeof(*p) == 24
	sizeof(p->a) == 1
	sizeof(p->e) == 4

	sizeof(p) == 8  P为指针，64位系统地址占8个字节
	sizeof(*p) == 24 根据内存对齐  32字节  a_ _ _ _ _ _ _ | * d  8字节|  | b4字节|  |c2字节|_ _ |e8字节|
	sizeof(p->a) == 1 正确
	sizeof(p->e) == 8  double

16位系统最大只能支持1M的物理内存地址，32位最大可以支持4G的物理内存地址，64位可以最大支持128G物理内存地址

![](https://img-blog.csdn.net/20180712214243813?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXJyeWRyZWFtc292ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 线程间共享变量

假设下面的函数foo会被多线程调用，那么让i、j、k三个变量哪些因为线程间共享访问需要加锁保护.()

	int i = 0;
	void foo()
	{
	    static int j = 0;
	    int k = 0;
	    i++; j++; k++;
	}

答案是： i和j

多线程调用时要进行保护时，主要是针对全局变量和静态变量的，函数内的局部变量不会受到影响。

这里i是全局变量，j是局部静态变量，所以 要进行保护。


### 拷贝构造函数

以下代码是否完全正确，执行可能得到的结果是____。

	class A{
	   int i;
	};
	class B{
	   A *p;
	public:
	   B(){p=new A;}
	   ~B(){delete p;}
	};
	void sayHello(B b){
	}
	int main(){
	   B b;
	   sayHello(b);
	}


答案： 程序崩溃

默认的拷贝构造函数是浅拷贝，直接把指针的值复制了一份。调用sayHello，离开作用域，调用析构函数delete了一次。main函数中，又delete了一次。因此程序崩溃。

正确的做法：

在B中添加拷贝构造函数：

	B(const B& temp)
	{
		p = new A;
		*p = *(temp.p);
	}

### 对象

面向对象程序设计中，对象=（   ）

对象和消息

类代表算法和数据结构的集合。
对象指的是对象本身和对象间的消息传递，不是简简单单一个对象搁在那，这是面向对象区别于其他的重要特点。
这题考的意思就是告诉咱们在面向对象中，对象不仅仅是孤零零的，同时它们之间是通过消息进行交互的。是这个意思。所以说是对象+消息。


### 变量在堆栈

请看一下这一段C++代码，如果编译后程序在windows下运行，则一下说话正确的是?
	
	char*p1 = “123456”;
	char*p2 = (char*)malloc(10);

正确答案: A C   

	p1 和 p2都存在栈中
	p2指向的10个字节内存在栈中
	堆和栈在内存中的生长方向是相反的
	“123456”这6个字符存储在栈中

解释：

生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，他的生长方向是向下的，是向着内存地址减小的方向增长。

一个由C/C++编译的程序占用的内存分为以下几个部分

- 1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其 
操作方式类似于数据结构中的栈。 
- 2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。 
- 3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的 全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后由系统释放。 
- 4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放 
- 5、程序代码区—存放函数体的二进制代码。 