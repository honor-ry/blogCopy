---
title: 图床项目笔记
date: 2019-11-18 10:44:14
tags: 项目
mathjax: true
---



自学习项目，具体教程来自B站学习视频。采用FASTDFS，Redis，Mysql，FastCGI, QT，C，C++等实现一个图床！<!--more-->

# 项目架构

- 通过浏览器/桌面客户端访问服务器
  - c/s
  - b/s

- 反向代理服务器
  - 多台web服务器-集群
  - 给web服务器分配资源
- 高并发
  - 多态web服务器
- nginx服务器+FastCGI
  - nginx处理静态请求
  - 动态请求需要FastCGI处理
- 数据：mysql+redis
  - mysql存储很少访问的数据，比如用户名和密码，只要登陆才访问
  - redis存储频繁访问的数据
- 分布式文件系统-FastDFS
  - 上传和下载文件

项目架构图：

![](https://raw.githubusercontent.com/zxpgo/images/master/img/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E5%9B%BE2.jpg)

## Web服务器

常见的web服务器：

- tomcat服务器
  - apache组织的产品，开源的免费服务器
  - 多用于java项目
- Apache服务器
- weblogic服务器
  - bea公司，收费的服务器
  - 不交费，访问量受限制
- IIS服务器
  - Internet Information Server
  - 微软公司主推的服务器
- nginx
  - 小巧且高效的HTTP服务器
  - 也可以做一个高效的负载均衡反向代理

## FASTDFS

文件系统--存储数据

FAT32、NTFS、ext3、ext4....

分布式文件系统：

- 文件系统的全部，不在同一台主机上，在很多太主机上，多个分散的文件系统组合在一起，形成一个完整的文系统。
- 分布式的文件系统基本结构



FastDFS实现分布式文件系统的搭建。

### FASTDFS概述

- FASTDFS是用C语言编写的一款开源的分布式文件系统。淘宝架构师--徐庆编写的。

- 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容，并注重高可用、高性能等指标

- 可以很容易搭建一套高性能的文件服务器提供文件下载、上传等服务。比如图片服务器。

### FASTDFS特点

- 应用层级的文件系统
- 不能挂载和卸载，也就是不能进行mount操作



### FASTDFS框架中三个角色

- 追踪器 Tracker
- 存储节点 Storage
- 客户端 Client

下图是一个FastDFS集群：

![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=af11309fbb119313d34ef7e2045167b2/9345d688d43f87945890b673db1b0ef41bd53a04.jpg)



Client和Storage主动连接Tracker。

- Storage主动向Tracker报告其状态信息
  - 磁盘剩余空间
  - 文件同步状况
  - 文件上传下载次数
- Storage会启动一个单独的线程来完成对一台Tracker的连接和定时报告。
- 一个组包含的Storage不是通过配置文件设定的，而是通过Tracker获取的。

Web或客户端连接Tracker，获取存储节点的IP和端口，然后利用IP和端口将文件上传到存储节点。下载的时候同样首先询问Tracker，我要下载的文件存储在哪台服务器上？Tracker返回IP和端口给用户，用户在通过IP和端口从存储节点上下载文件。



Tracker集群：

- Tracker server不存在单点故障
- Tracker server之间是相互平等关系同时提供服务
- 客户端请求Tracker server采用轮询方式，如果请求的tracker无法提供服务则换另一个tracker。

Storage集群：

- Storage集群采用了分组存储方式，有一个或多个组构成
- 集群存储总量为集群中所有组的存储容量之和，每个组的存储容量为组内Storage容量最小的值（木桶效应，因为组内的Storage是为了做备份）。
- 一个组由一台或多台存储服务器组成，组内的Storage server之间是平等关系
- 不同组的Storage server之间不会相互通信，同组内的Storage server之间会相互连接进行文件同步，从而保证同组内每个storage上的文件完全一致的。
- 一个组的存储容量为该组内存储服务器容量最小的那个。

FastDFS的扩容：

- 纵向扩容
  - 数据备份
  - 当前组的最大容量为存储节点最小的那个
  - 所有存储节点组名必须一样

- 横向扩容
  - 增加存储空间
  - 添加Group组

### FASTDFS安装

首先安装**libfastcommon**库：

```Shell
#下载源码
git clone https://github.com/happyfish100/libfastcommon.git
#安装教程查看源码里面的INSTALL文件
./make.sh
./make.sh install
```

安装fastdfs

```shell
wget https://jaist.dl.sourceforge.net/project/fastdfs/FastDFS%20Server%20Source%20Code/FastDFS%20Server%20with%20PHP%20Extension%20Source%20Code%20V5.08/FastDFS_v5.08.tar.gz

#安装方式跟libfastcommon相同
./make.sh
./make.sh install

#测试安装成功
fdfs_test #输出版本信息表示成功
```

### FASTDFS配置

默认配置文件位置：`/etc/fdfs`

主要所有的配置文件加上了一个sample，我们需要重新复制一下，重新修改配置文件。

Tracker配置

- bind_addr:当前主机的IP
- port:绑定的端口
- log日志目录

```shell
bind_addr=192.168.80.110

# the tracker server port
port=22122

# the base path to store data and log files
base_path=/root/fdfs/tracker

```

Storage配置

- group_name：存储节点所属的组
- bind_addr：本机IP地址
- port：端口
- base_path存储日志的目录
- store_path_count：数据存储目录的个数
- store_path0：第一个具体的存储目录，store_path1以此类推
- tracker_server：tarcker的IP和端口

```shell
group_name=group1

# bind an address of this host
# empty for bind all addresses of this host
bind_addr=192.168.80.110

# the storage server port
port=23000

# the base path to store data and log files
base_path=/root/fdfs/storage

# path(disk or mount point) count, default value is 1
store_path_count=1

# store_path#, based 0, if store_path0 not exists, it's value is base_path
# the paths must be exist
store_path0=/root/fdfs/storage
#store_path1=/home/yuqing/fastdfs2

tracker_server=192.168.80.110:22122

```

Client配置：

- log日志目录
- tracker_server的IP和端口

```shell
# the base path to store log files
base_path=/root/fdfs/client

# tracker_server can ocur more than once, and tracker_server format is
#  "host:port", host can be hostname or ip address
tracker_server=192.168.80.110:22122
```

### FASTDFS启动

第一步，启动Tracker：

```shell
fdfs_trackerd /etc/fdfs/tracker.conf
fdfs_trackerd /etc/fdfs/tracker.conf restart  #重启
fdfs_trackerd /etc/fdfs/tracker.conf stop     #关闭
```

第二步，启动Storage

```shell
fdfs_storaged /etc/fdfs/storage.conf
fdfs_storaged /etc/fdfs/storage.conf restart 
fdfs_storaged /etc/fdfs/storage.conf stop
```

通过查看进程是否起来，判断以上两个命令是否运行成功：

```shell
ps aux | grep fdfs*
```

最后通过客户端来测试是否启动成功：

```shell
fdfs_monitor /etc/fdfs/client.conf
#输出信息
server_count=1, server_index=0

tracker server is 192.168.80.110:22122

group count: 1

Group 1:
group name = group1
disk total space = 17394 MB
disk free space = 14491 MB
trunk free space = 0 MB
storage server count = 1
active server count = 1
storage server port = 23000
storage HTTP port = 8888
store path count = 1
subdir count per path = 256
current write server index = 0
current trunk file id = 0

	Storage 1:
		id = 192.168.80.110
		ip_addr = 192.168.80.110 (k8s-master)  ACTIVE  #表示启动成功
		http domain = 
		version = 5.08
		join time = 2019-09-04 02:28:14
		up time = 2019-09-04 02:28:14
		total storage = 17394 MB
```

注意：所有fdfs的可执行文件都在`/usr/bin`目录下：

```shell
[root@k8s-master fdfs]# ls /usr/bin/fdfs*
/usr/bin/fdfs_appender_test   /usr/bin/fdfs_append_file  /usr/bin/fdfs_delete_file    /usr/bin/fdfs_file_info  /usr/bin/fdfs_storaged  /usr/bin/fdfs_test1     /usr/bin/fdfs_upload_appender
/usr/bin/fdfs_appender_test1  /usr/bin/fdfs_crc32        /usr/bin/fdfs_download_file  /usr/bin/fdfs_monitor    /usr/bin/fdfs_test      /usr/bin/fdfs_trackerd  /usr/bin/fdfs_upload_file

```

上传文件测试：

```shell
fdfs_upload_file /etc/fdfs/client.conf INSTALL  #INSTALL就是上传的文件，比如在当前目录下
#输出id
group1/M00/00/00/wKhQbl1vW3iAEpsuAAAeS70IE2U1586163 #M00对应我们设置的目录 /root/fdfs/storage
#现在就可以在我们设置的存储路径下查看数据
[root@k8s-master storage]# ls
data  logs
[root@k8s-master storage]# cd data
[root@k8s-master data]# ls
00  09  12  1B  24  2D  36  3F  48  51  5A  63  6C  75  7E  87  90  99  A2  AB  B4  BD  C6  CF  D8  E1  EA  F3  FC
01  0A  13  1C  25  2E  37  40  49  52  5B  64  6D  76  7F  88  91  9A  A3  AC  B5  BE  C7  D0  D9  E2  EB  F4  FD
02  0B  14  1D  26  2F  38  41  4A  53  5C  65  6E  77  80  89  92  9B  A4  AD  B6  BF  C8  D1  DA  E3  EC  F5  fdfs_storaged.pid
03  0C  15  1E  27  30  39  42  4B  54  5D  66  6F  78  81  8A  93  9C  A5  AE  B7  C0  C9  D2  DB  E4  ED  F6  FE
04  0D  16  1F  28  31  3A  43  4C  55  5E  67  70  79  82  8B  94  9D  A6  AF  B8  C1  CA  D3  DC  E5  EE  F7  FF
05  0E  17  20  29  32  3B  44  4D  56  5F  68  71  7A  83  8C  95  9E  A7  B0  B9  C2  CB  D4  DD  E6  EF  F8  storage_stat.dat
06  0F  18  21  2A  33  3C  45  4E  57  60  69  72  7B  84  8D  96  9F  A8  B1  BA  C3  CC  D5  DE  E7  F0  F9  sync
07  10  19  22  2B  34  3D  46  4F  58  61  6A  73  7C  85  8E  97  A0  A9  B2  BB  C4  CD  D6  DF  E8  F1  FA
08  11  1A  23  2C  35  3E  47  50  59  62  6B  74  7D  86  8F  98  A1  AA  B3  BC  C5  CE  D7  E0  E9  F2  FB
[root@k8s-master data]# cd 00
[root@k8s-master 00]# ls
00  08  10  18  20  28  30  38  40  48  50  58  60  68  70  78  80  88  90  98  A0  A8  B0  B8  C0  C8  D0  D8  E0  E8  F0  F8
01  09  11  19  21  29  31  39  41  49  51  59  61  69  71  79  81  89  91  99  A1  A9  B1  B9  C1  C9  D1  D9  E1  E9  F1  F9
02  0A  12  1A  22  2A  32  3A  42  4A  52  5A  62  6A  72  7A  82  8A  92  9A  A2  AA  B2  BA  C2  CA  D2  DA  E2  EA  F2  FA
03  0B  13  1B  23  2B  33  3B  43  4B  53  5B  63  6B  73  7B  83  8B  93  9B  A3  AB  B3  BB  C3  CB  D3  DB  E3  EB  F3  FB
04  0C  14  1C  24  2C  34  3C  44  4C  54  5C  64  6C  74  7C  84  8C  94  9C  A4  AC  B4  BC  C4  CC  D4  DC  E4  EC  F4  FC
05  0D  15  1D  25  2D  35  3D  45  4D  55  5D  65  6D  75  7D  85  8D  95  9D  A5  AD  B5  BD  C5  CD  D5  DD  E5  ED  F5  FD
06  0E  16  1E  26  2E  36  3E  46  4E  56  5E  66  6E  76  7E  86  8E  96  9E  A6  AE  B6  BE  C6  CE  D6  DE  E6  EE  F6  FE
07  0F  17  1F  27  2F  37  3F  47  4F  57  5F  67  6F  77  7F  87  8F  97  9F  A7  AF  B7  BF  C7  CF  D7  DF  E7  EF  F7  FF
[root@k8s-master 00]# cd 00
[root@k8s-master 00]# ls
wKhQbl1vW3iAEpsuAAAeS70IE2U1586163

#下载文件
[root@k8s-master ~]# fdfs_download_file /etc/fdfs/client.conf group1/M00/00/00/wKhQbl1vW3iAEpsuAAAeS70IE2U1586163
[root@k8s-master ~]# ls
alloc.c  anaconda-ks.cfg  download  fdfs  wKhQbl1vW3iAEpsuAAAeS70IE2U1586163
```

### 文件上传和下载流程

文件上传：

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190904145854.png)

文件下载：

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190904150702.png)

group1/M00/00/00/wKhQbl1vW3iAEpsuAAAeS70IE2U1586163

- group1组名
- M00 虚拟磁盘路径，对应store_path*=...
- 00/00 二级目录，存储文件的目录
- wKhQbl1vW3iAEpsuAAAeS70IE2U1586163文件名

文件名包含的信息：

- 采用Base64编码
- 包含的字段：
  - 源storage server IP
  - 文件创建时间
  - 文件大小
  - 文件CRC32校验码（循环冗余校验）
  - 随机数

### 找不到动态库.so的问题

第一种：

- 使用环境变量LD_LIBRARY_PATH
- 动态库的绝对路径添加到该环境变量中
- LD_LIBRARY_PATH=/usr/include/...:$LD_LIBRARY_PATH
- export LD_LIBRARY_PATH
  - 直接在shell中执行 - 临时设置，重启失效
  - 写入配置文件
    - ~/.bashrc -用户级别
    - /etc/prefile - 系统级别

第二种：

- 给动态库设置软链接 /usr/kevin/fastdfs
- 将软链接放到/usr/lib /usr/lib64 /lib /lib64
- sudo ln -s /usr/kevin/fastdfs/xxx.so  /usr/lib/libxxx.so

第三种：

- 刷新/etc/ld.so.cache
  - 首先 vi /etc/ld.so.conf，将动态库的绝对路径写入该文件中
  - sudo ldconfig -v

### 代码实现FastDFS文件上传和下载

两种方式：

- FastDFS API实现
- 进程方式实现

#### 源码分析

`FastDFS/client`目录下，存放了所有有关client的文件，其中有一个`fdfs_upload_file.c`，因为每一个执行文件都会对应一个.c文件，所以`fdfs_upload_file`对应`fdfs_upload_file.c`，里面实现了文件上传的功能。具体源码如下：

```C++
/**
* Copyright (C) 2008 Happy Fish / YuQing
*
* FastDFS may be copied only under the terms of the GNU General
* Public License V3, which may be found in the FastDFS source kit.
* Please visit the FastDFS Home Page http://www.csource.org/ for more detail.
**/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "fdfs_client.h"
#include "logger.h"

static void usage(char *argv[])
{
	printf("Usage: %s <config_file> <local_filename> " \
		"[storage_ip:port] [store_path_index]\n", argv[0]);
}

int main(int argc, char *argv[])
{
	char *conf_filename;
	char *local_filename;
	char group_name[FDFS_GROUP_NAME_MAX_LEN + 1];
	ConnectionInfo *pTrackerServer;
	int result;
	int store_path_index;
	ConnectionInfo storageServer;
	char file_id[128];
	
	if (argc < 3)
	{
		usage(argv);
		return 1;
	}

	log_init();
	g_log_context.log_level = LOG_ERR;
	ignore_signal_pipe();

	conf_filename = argv[1];
    //通过客户端配置文件初始化一些数据
	if ((result=fdfs_client_init(conf_filename)) != 0)
	{
		return result;
	}
	//通过从配置文件中读出的数据链接tracker
    //通过pTrackerServer可以访问tracker
	pTrackerServer = tracker_get_connection();
	if (pTrackerServer == NULL)
	{
		fdfs_client_destroy();
		return errno != 0 ? errno : ECONNREFUSED;
	}

	local_filename = argv[2];
	*group_name = '\0';
    //不需要
	if (argc >= 4)
	{
		const char *pPort;
		const char *pIpAndPort;

		pIpAndPort = argv[3];
		pPort = strchr(pIpAndPort, ':');
		if (pPort == NULL)
		{
			fdfs_client_destroy();
			fprintf(stderr, "invalid storage ip address and " \
				"port: %s\n", pIpAndPort);
			usage(argv);
			return 1;
		}

		storageServer.sock = -1;
		snprintf(storageServer.ip_addr, sizeof(storageServer.ip_addr), \
			 "%.*s", (int)(pPort - pIpAndPort), pIpAndPort);
		storageServer.port = atoi(pPort + 1);
		if (argc >= 5)
		{
			store_path_index = atoi(argv[4]);
		}
		else
		{
			store_path_index = -1;
		}
	}
    //通过追踪器得到存储节点的信息
	else if ((result=tracker_query_storage_store(pTrackerServer, \
	                &storageServer, group_name, &store_path_index)) != 0)
	{
		fdfs_client_destroy();
		fprintf(stderr, "tracker_query_storage fail, " \
			"error no: %d, error info: %s\n", \
			result, STRERROR(result));
		return result;
	}
	//上传文件
	result = storage_upload_by_filename1(pTrackerServer, \
			&storageServer, store_path_index, \
			local_filename, NULL, \
			NULL, 0, group_name, file_id);
	if (result == 0)
	{
		printf("%s\n", file_id);
	}
	else
	{
		fprintf(stderr, "upload file fail, " \
			"error no: %d, error info: %s\n", \
			result, STRERROR(result));
	}
	//跟tracker端口连接
	tracker_disconnect_server_ex(pTrackerServer, true);
    //销毁client客户端
	fdfs_client_destroy();

	return result;
}



//修改版
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "fdfs_client.h"
#include "logger.h"

int fdfs_upload_file(const char * conf_filename, const char * local_filename, char * file_id)
{
	char group_name[FDFS_GROUP_NAME_MAX_LEN + 1];
	ConnectionInfo *pTrackerServer;
	int result;
	int store_path_index;
	ConnectionInfo storageServer;

    //通过客户端配置文件初始化一些数据
	if ((result=fdfs_client_init(conf_filename)) != 0)
	{
		return result;
	}
	//通过从配置文件中读出的数据链接tracker
    //通过pTrackerServer可以访问tracker
	pTrackerServer = tracker_get_connection();
	if (pTrackerServer == NULL)
	{
		fdfs_client_destroy();
		return errno != 0 ? errno : ECONNREFUSED;
	}

	*group_name = '\0';
    //通过追踪器得到存储节点的信息
	if ((result=tracker_query_storage_store(pTrackerServer, \
	                &storageServer, group_name, &store_path_index)) != 0)
	{
		fdfs_client_destroy();
		fprintf(stderr, "tracker_query_storage fail, " \
			"error no: %d, error info: %s\n", \
			result, STRERROR(result));
		return result;
	}
	//上传文件
	result = storage_upload_by_filename1(pTrackerServer, \
			&storageServer, store_path_index, \
			local_filename, NULL, \
			NULL, 0, group_name, file_id);
	if (result == 0)
	{
		printf("%s\n", file_id);
	}
	else
	{
		fprintf(stderr, "upload file fail, " \
			"error no: %d, error info: %s\n", \
			result, STRERROR(result));
	}
	//跟tracker端口连接
	tracker_disconnect_server_ex(pTrackerServer, true);
    //销毁client客户端
	fdfs_client_destroy();

	return result;
}
```

#### 进程方式实现

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190904160251.png)

- 创建一个匿名管道
- 创建子线程
- 子进程中执行execlp()
  - 关闭读端
  - 将读到的文件ID写入管道
- 父进程
  - 关闭写端
  - 读管道：将文件ID读到内存
  - 回收子进程的PCB

父子进程始终共享的东西：

-  文件描述符 
  - open
  - pipe
- 内存映射区 mmap

## Redis

数据库类型：

- 关系型数据库：SQL
  - 使用SQL语句进行操作
  - 数据存储在磁盘
  - 常见：MySQL, Oracle，SQLite，SQLServer
- 非关系型数据库：noSQL
  - 不依赖SQL语句
  - 数据存储在内存中
  - 数据可以持久化，即将数据保存到磁盘
  - 数据都是键值对
  - 常用：Redis, MemCache

缓存数据库和持久数据库的搭配使用：

<img src="https://raw.githubusercontent.com/zxpgo/images/master/img/20190904192126.png" style="zoom:75%;" />

第一次读取从持久化数据库读取，并将数据写入缓存数据库中。然后后面的用户读取就直接从缓存数据库读取，提高了访问的速度。

Redis是单线程工作模式，因为在内存中处理速度快。内部维护了一个队列，将要处理的操作放入队列中。

### 安装

```shell
$ wget http://download.redis.io/releases/redis-5.0.4.tar.gz
$ tar xzf redis-5.0.4.tar.gz
$ cd redis-5.0.4
$ make

#启动服务器
$ redis-server
#还可以加上配置文件启动
$ redis-server ./redis.conf
#启动客户端
$ redis-cli
#如果redis.conf中修改了端口
$ redis-cli -p port
#远程访问时，需要在redis.conf注释掉bind，在登陆时还需要添加IP
$ redis-cli -h IP -p port
#客户端测试
> ping
#显示PONG表示安装成功
#客户端关闭服务器
>shutdown
```

### 数据类型

Readis中所有的数据都是键值对。

- key：字符串
- 常用的数据类型：
  - 字符串类型
  - Hash类型
  - List类型：字符串数组
  - Set类型
  - SortedSet类型zset

Redis命令：http://redis.cn/commands.html#

#### string

```shell
[root@k8s-master ~]# redis-cli
127.0.0.1:6379> SET str1 hello
OK
127.0.0.1:6379> GET str1
"hello"
127.0.0.1:6379> SET str 123
OK
127.0.0.1:6379> get str
"123"
127.0.0.1:6379> mset str2 123 str4 345
OK
127.0.0.1:6379> keys *
1) "str4"
2) "str1"
3) "str2"
4) "str"
127.0.0.1:6379> mget str1 str2 str4 str
1) "hello"
2) "123"
3) "345"
4) "123"
127.0.0.1:6379> incr str1
(error) ERR value is not an integer or out of range
127.0.0.1:6379> incr str2
(integer) 124
127.0.0.1:6379> get str2
"124"
127.0.0.1:6379> decr str2
(integer) 123
127.0.0.1:6379> get str2
"123"
127.0.0.1:6379> append str1 world
(integer) 10
127.0.0.1:6379> get str1
"helloworld"

```

#### List类型：

操作过程中，既可以按照队列操作，也快成按照栈操作

- 队列：

  队头出数据，队尾进数据

  rpush     lpop

- 栈

  只能操作栈顶

  lpush lpop

  或者rpush rpop

```shell
127.0.0.1:6379> lpush ls1 aaa bbb ccc ddd 123
(integer) 5
127.0.0.1:6379> lrange ls1 0 -1
1) "123"
2) "ddd"
3) "ccc"
4) "bbb"
5) "aaa"
127.0.0.1:6379> rpush ls1 9 8 7 6
(integer) 9
127.0.0.1:6379> lrange ls1 0 -1
1) "123"
2) "ddd"
3) "ccc"
4) "bbb"
5) "aaa"
6) "9"
7) "8"
8) "7"
9) "6"
127.0.0.1:6379> lpop ls1
"123"
127.0.0.1:6379> rpop ls1
"6"
127.0.0.1:6379> llen ls1
(integer) 7
```

#### set

集合类型，集合元素是没有顺序的，但是元素是唯一的。利用set可以就交集、并集和差集。

```shell
127.0.0.1:6379> sadd set1 1 2 3 4 4 5 6 7
(integer) 7
127.0.0.1:6379> smembers set1
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"
7) "7"
127.0.0.1:6379> sadd set2 4 5 6 7 8 9 
(integer) 6
127.0.0.1:6379> sdiff set1 set2
1) "1"
2) "2"
3) "3"
127.0.0.1:6379> sdiff set2 set1
1) "8"
2) "9"
127.0.0.1:6379> sinter set1 set2
1) "4"
2) "5"
3) "6"
4) "7"
127.0.0.1:6379> sunion set1 set2
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"
7) "7"
8) "8"
9) "9"

```

#### sorted

集合中每一个元素都有一个分数，Sortedset会根据分数进行排序。

```shell
127.0.0.1:6379> zadd zset1 6 hello 1 world 8 abc
(integer) 3
127.0.0.1:6379> zrange zset1 0 -1
1) "world"
2) "hello"
3) "abc"
127.0.0.1:6379> zrange zset1 0 -1 withscores
1) "world"
2) "1"
3) "hello"
4) "6"
5) "abc"
6) "8"
127.0.0.1:6379> zrevrange zset1 0 -1 withscores
1) "abc"
2) "8"
3) "hello"
4) "6"
5) "world"
6) "1"

```

#### hash

```shell
key		 value 
string	  key: value
		  key: vlue
#测试
127.0.0.1:6379> hset user usrname 张3
(integer) 1
127.0.0.1:6379> hset user age 18
(integer) 1
127.0.0.1:6379> hset user passwd 123456
(integer) 1
127.0.0.1:6379> hget user usrname
"\xe5\xbc\xa03"
127.0.0.1:6379> hget user age
"18"
127.0.0.1:6379> hmset zhang3 sex man age 18 disp gay
OK
127.0.0.1:6379> hmget zhang3 sex age disp
1) "man"
2) "18"
3) "gay"
```

`hgetall key`能够获取所有的键值对

#### 对于key的操作

```shell
127.0.0.1:6379> keys *
 1) "set1"
 2) "str2"
 3) "zset1"
 4) "set2"
 5) "str"
 6) "ls1"
 7) "user"
 8) "zhang3"
 9) "str4"
10) "str1"
127.0.0.1:6379> keys str*
1) "str2"
2) "str"
3) "str4"
4) "str1"
#key的生存时间
127.0.0.1:6379> expire str1 60
(integer) 1
127.0.0.1:6379> TTL str1
(integer) 35
127.0.0.1:6379> TTL str1
(integer) -2
#清空生成时间
127.0.0.1:6379> persist str1
(integer) 0
#设置时间为毫秒，默认为秒
127.0.0.1:6379> pexpire str1 60
(integer) 0
127.0.0.1:6379> TTL str1
(integer) -2
127.0.0.1:6379> del set2
(integer) 1
127.0.0.1:6379> keys *
1) "set1"
2) "str2"
3) "zset1"
4) "str"
5) "ls1"
6) "user"
7) "zhang3"
8) "str4"
127.0.0.1:6379> rename str4 str3
OK
```

`type key`获取key的类型。

### 配置文件

如果远程连接，需要将修改配置文件：

- 注释bind
- protected-mode改为no

```shell
#bind 127.0.0.1
protected-mode no #远程访问设置为no
daemonize yes   #是否为守护，默认为no不是守护进程，修改为yes,如果是守护进程会生成一个redis.pid文件存储该进程的PID
pidfile ./redis.pid #pid存储目录，修改后为输入命令所在的目录
logfile "./redis.log"  #默认为/dev/null，相当于放进垃圾桶
databases 16 #redis默认有16个数据库  使用setlect 0选择第一个数据库
```

如果使用配置文件启动redis服务端，需要将配置文件拷贝到当前目录下，然后在启动命令后面加上配置文件：

```shell
redis-server ./redis.conf
```

如果端口换了：

```shell
redis-cli -p 6380
```

远程访问：

```shell
redis-cli -h 192.168.80.110 -p 6380 #端口更改后的
```

### 数据持久化

redis两种持久化方式：

- rdb形式：默认方式
  - 特点：快照的方式，存储的是内存中的数据；按照某种频率存储数据
  - 缺点：存储的频率太高，存储效率低；频率太低，同步不及时
  - 优点：数据恢复要快一些
- Aof形式
  - 特点：存储的是命令
  - 缺点：数据恢复时间长(读取命令，还要执行命令)
  - 优点：

以上持久化设置都可以在配置文件完成。

```shell
save 900 1            #900秒内至少有一个key改变，就保存
save 300 10	          #300秒内至少10个改变，就保存
save 60 10000
```

修改存储形式：

```shell
rdbcompression yes         
appendonly no  #二选一

# The name of the append only file (default: "appendonly.aof")
appendfilename "appendonly.aof"

# appendfsync always
appendfsync everysec  #更新频率
# appendfsync no
```

### hiredis API接口使用

#### 安装

```shell
#下载源码
git clone https://github.com/redis/hiredis.git
#进入对应的目录
cd hiredis
#编译
make
#安装
make install
```

所有的接口都在源码的`hiredis.h`文件中，在examples文件夹下有使用的例子，主要看`examples.c`就可以。还有在qt里面如何使用等等。

#### 连接数据库

```c
redisContext* redisConnect(const char* ip, int port);
```

- 参数
  - IP
  - 端口

redisContext结构体：

```c
typedef struct redisContext {
    int err; /* Error flags, 0 when there is no error */
    char errstr[128]; /* String representation of error when applicable */
    redisFD fd; //文件描述符
    int flags;   
    char *obuf; /* Write buffer */
    redisReader *reader; /* Protocol reader */

    enum redisConnectionType connection_type;
    struct timeval *timeout;

    struct {
        char *host;            
        char *source_addr;
        int port;
    } tcp;               //套接字通信

    struct {
        char *path;
    } unix_sock;

    /* For non-blocking connect */
    struct sockadr *saddr;
    size_t addrlen;
    /* For SSL communication */
    struct redisSsl *ssl;

} redisContext;
```

#### 发送请求命令

```c
void* redisCommand(redisContext* c, const char * format, ...);
```

返回值：

- 返回值是一个void类型的指针，实际上指向一个redisReply类型的指针。

```c
typedef struct redisReply {
    int type; /* REDIS_REPLY_,执行结果返回的类型* */
    long long integer; /* The integer when type is REDIS_REPLY_INTEGER */
    double dval; /* The double when type is REDIS_REPLY_DOUBLE */
    size_t len; /* Length of string */
    char *str; /* Used for REDIS_REPLY_ERROR, REDIS_REPLY_STRING
                  and REDIS_REPLY_DOUBLE (in additionl to dval). */
    size_t elements; /* number of elements, for REDIS_REPLY_ARRAY */
    struct redisReply **element; /* elements vector for REDIS_REPLY_ARRAY */
} redisReply;

```

返回的类型包括：

- REDIS_REPLY_INTEGER

- REDIS_REPLY_STRING

- REDIS_REPLY_ARRAY

- REDIS_REPLY_ERROR

对于返回类型为数组时，处理方式如下：

```c
    reply = redisCommand(c,"LRANGE mylist 0 -1");
    if (reply->type == REDIS_REPLY_ARRAY) {
        for (j = 0; j < reply->elements; j++) {
            printf("%u) %s\n", j, reply->element[j]->str);
        }
    }
    freeReplyObject(reply);

```

#### 释放资源

```c
void freeReplyObject(void * reply);  //用来释放分配的资源
void redisFree(redisContext * c);  //用来释放分配的资源
```

## Mysql

安装教程：https://blog.csdn.net/pengjunlee/article/details/81212250

设置远程访问：https://www.cnblogs.com/weifeng1463/p/7941625.html

### 设置默认编码

```mysql
>\s #查看编码信息
mysql> \s
--------------
mysql  Ver 14.14 Distrib 5.6.45, for Linux (x86_64) using  EditLine wrapper

Connection id:		3
Current database:	mysql
Current user:		root@localhost
SSL:			Not in use
Current pager:		stdout
Using outfile:		''
Using delimiter:	;
Server version:		5.6.45 MySQL Community Server (GPL)
Protocol version:	10
Connection:		Localhost via UNIX socket
Server characterset:	latin1  #需要修改为utf8
Db     characterset:	latin1  #需要修改为utf8
Client characterset:	utf8
Conn.  characterset:	utf8
UNIX socket:		/var/lib/mysql/mysql.sock
Uptime:			13 min 25 sec

Threads: 4  Questions: 56  Slow queries: 0  Opens: 87  Flush tables: 1  Open tables: 80  Queries per second avg: 0.069
--------------
```

centos7下如何修改默认编码：

- 进入配置文件修改配置内容，执行命令：`vi /etc/my.cnf`

- 修改配置文件的内容，在[mysqld]结束位置添加：`character_set_server=utf8`
- 重启mysql服务：`systemctl restart mysql`

### 设置字段名大小写不敏感

- 进入配置文件修改配置内容，执行命令：`vi /etc/my.cnf`

- 修改配置文件的内容，在[mysqld]结束位置添加：`lower_case_table_names=1`
- 重启mysql服务：`systemctl restart mysql`

## Shell脚本

后缀一般为.sh。

```shell
#!/bin/bash  
#第一行不是注释，而是指定解析shell的命令解析器
ls -l
echo "hello world"
```

添加执行权限：`chmod u+x hello.sh`

执行脚本：`./hello.sh`

条件判断：

```shell
if [ 判断语句 ]; then
	xxx
elif [ 判断语句 ]; then
	xxx
else
	xxx
fi
#if和中括号中间有一个空格
#中括号内判断语句前后必须有一个空格
```

### 特殊变量

$#: shell执行的时候，传递的参数个数，`./xxxsh aa bb cc dd`，一共四个参数。

$? : 上一条shell命令执行完成之后的返回值

$@: 所有的参数

$*: 所有的参数

$1: 表示第一个参数，依此类推

### 变量

- 变量的定义

`var="hello"`

变量的值默认是字符串类型

变量名建议大写

- 赋值：

`var=10`等于前后不能有空格

如果有空格，就是判断是否等于10。

- 删除变量：-

​	`unset var`

- 将命令执行之后的值赋给变量：

  ```shell
  #方法一：使用反单引号
  [root@k8s-node1 html]# var=`date`
  [root@k8s-node1 html]# echo $var
  Thu Sep 5 22:24:10 EDT 2019
  #方法二：date是一个命令，所以加上()
  [root@k8s-node1 html]# var=$(date)
  [root@k8s-node1 html]# echo $var
  Thu Sep 5 22:25:50 EDT 2019
  ```



- 算数运算符

  变量先取值，在运算，取值方式有两种

  ```shell
  [root@k8s-node1 html]# var=3
  [root@k8s-node1 html]# var=$[$var+3]
  [root@k8s-node1 html]# echo $var
  6
  [root@k8s-node1 html]# var=$(($var+3))
  [root@k8s-node1 html]# echo $var
  9
  ```

  

## Nginx

nginx只能处理静态网页。

### nginx介绍

nginx的全称是engine x，由俄罗斯人开发的。nginx可以实现的功能：

- http服务器：能处理http协议的软件
- 反向代理服务器
- 邮件服务器
  - IMAP/POP3/SMTP

nginx的优势：

- 速度更快：高峰期nginx可以比其他web服务器更快的响应请求
- 高扩展：低耦合设计的模块组成，丰富的第三方模块支持
- 高可靠：经过大批网站检验，每个worker进程相对独立，出错之后可以快速开启新的worker
- 低内存消耗：一般情况下，10000个非活跃的HTTP Keep-Alive连接在nginx中仅消耗2.5M内存
- 单机支持10万以上的并发连接，取决于内存，10万远不封顶
- 热部署：master和worker的分离设计，可实现24小时不间断服务器的前提下审计nginx可执行文件
- 最自由的BSD许可协议：BSD许可协议允许用户免费使用nginx，修改nginx源码，然后再发布

### 正向代理和反向代理

#### 正向代理：

代理内部网络对Internet的连接请求

客户机必须指定代理服务器。

比如VPN，就是正向代理，正向代理服务器是为**客户端服务的**。

#### 反向代理

反向代理服务器是为**服务器服务的**。

二者的区别：

- 正向代理
  - 典型用途是为防止墙的局域网客户端提供访问Internet的途径
  - 正向代理还可以使用缓冲特性减少网络使用率

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190905200156.png)

- 反向代理
  - 典型用途是将防火墙后面的服务器提供给Internet用户访问
  - 反向代理还可以为后端的多台服务器提供负载均衡，或为后端较慢的服务器提供缓冲服务。

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190905195706.png)



### 安装

Nginx相关依赖：

- OpenSSL: 数据加密
- PCRE：解析正则表达式
- ZLib：压缩和解压缩，http传输的数据都会进行压缩



nginx下载地址：http://nginx.org/en/download.html

openssl下载地址：https://www.openssl.org/source/old/

PCRE下载地址：https://sourceforge.net/projects/pcre/

ZLib下载地址：http://www.zlib.net/



openssl安装：

```shell
#下载包
wget https://www.openssl.org/source/old/1.0.1/openssl-1.0.1u.tar.gz #下载包
#解压
tar -xzvf openssl-1.0.1u.tar.gz
cd openssl-1.0.1u
#生成一个Makefile
./config 
make #时间较长
make install
```

安装PCRE:

```shell
#下载包
wget https://jaist.dl.sourceforge.net/project/pcre/pcre/8.40/pcre-8.40.tar.gz
#解压
tar -xzvf pcre-8.40.tar.gz
#可能需要安装gcc-c++
yum -y install gcc-c++
cd pcre-8.40
#安装
#生成Makefile
./configure
make install
```

安装ZLib

```shell
#下载包
wget http://www.zlib.net/zlib-1.2.11.tar.gz
#解压
tar -xzvf zlib-1.2.11.tar.gz
cd zlib-1.2.11
#安装
#生成Makefile
./configure
make install
```

安装nginx:

```shell
#下载包
 wget http://nginx.org/download/nginx-1.10.1.tar.gz
#解压
tar -xzvf nginx-1.10.1.tar.gz
cd nginx-1.10.1
#安装
#生成Makefile
./configure
make install
```

默认安装陌路：`/usr/local/nginx`

nginx配置文件目录：`/usr/local/nginx/conf`

nginx log目录：`/usr/local/nginx/logs`

静态网页存放位置：`/usr/local/nginx/html`，放入静态文件后还需要配置，后面介绍。

超级用户可执行程序所在位置：`/usr/local/nginx/sbin`

```shell
sudo ./usr/local/nginx/sbin/nginx
ps aux | grep nginx
#会看到启动两个进程，一个master，一个worker；master是一个管理者，worker是用来干活的
root      61733  0.0  0.0  20508   600 ?        Ss   08:49   0:00 nginx: master process ./nginx
nobody    61734  0.0  0.1  20928  1044 ?        S    08:49   0:00 nginx: worker process
```

现在可以通过IP进行访问。

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190905205805.png)

如果修改了配置文件，就需要nginx重新加载配置文件：

```shell
./nginx -s reload
```

默认监听80端口，所以访问是不需要加端口。

### nginx相关操作命令

将nginx可执行程序创建软链接放到/bin或/usr/bin 或/usr/local/bin：

```shell
ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx
```

现在就可以直接输入`nginx`来启动nginx服务。

关闭nginx：

```shell
nginx -s stop
```

上述命令比较粗暴，不管nginx是否工作做什么事，直接关闭。

下面的命令，则会等待nginx工作完毕才关闭：

```shell
nginx -s quit
```

热部署：

```shell
nginx -s reload  #重新加载配置文件
```

修改配置文件不需要重新启动。

### 配置文件

在conf/nginx.conf

```shell
#user  nobody;
worker_processes  1;  #work进程数量

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;
#pid        logs/nginx.pid;

events {
	#use epoll; #处理高并发      
    worker_connections  1024; #work连接的最大个数
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';
    #access_log  logs/access.log  main;
    sendfile        on;
    #tcp_nopush     on;
    #keepalive_timeout  0;
    keepalive_timeout  65;
    #gzip  on;
    server {
        listen       80;         #端口
        server_name  localhost;  #域名，不能写IP

        #charset koi8-r;
        #access_log  logs/host.access.log  main;
        location / {      #浏览器请求的指令
            root   html;          #静态资源根目录
            index  index.html index.htm; #index，会找index.html，找不到然后再找index.htm
        }

        #error_page  404              /404.html;
        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }


}
```

配置文件结构：

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190905212024.png)

- 一个server代表一个web服务器（或虚拟机）。

- location表示web服务器处理的一个指令，一个server一般有多个location来处理多个请求。



还可以添加一个模块就是mail，用来处理邮件相关的协议。默认是没有添加的。

### nginx部署静态网页

在nginx目录下，创建一个demo目录，放入一个newdetail.html文件。

在配置文件的server下添加如下内容：

```shell
	location /newdetail.html {
	    root demo;
        index newdetail.html;
	}

```

现在就可以通过IP加对应的html文件就可以访问了：

http://192.168.80.110/newdetail.html

### IP与域名

二者关系

- 一个IP可以被多个域名绑定
- 一个域名只能绑定一个IP

浏览器首先通过DNS向DNS域名服务器解析域名，得到IP，然后通过IP去访问域名对应的网站。

域名解析服务器：

- Pod DNS+
  - 首选：119.29.29.29
  - 备选：182.254.116.116
- 114DNS
  - 首选：114.114.114.114
  - 备选：114.114.114.115
- 阿里AliDNS
  - 首选：223.5.5.5
  - 备选：223.6.6.6

hosts文件：

hosts也是解析域名得到IP，相等于域名服务器。直接通过hosts文件可以解析。

```shell
127.0.0.1 php
127.0.0.1 websecurity.com127.0.0.1       activate.navicat.com
```

反向代理的前提：有多台web服务器。

### 反向代理设置

环境

- 反向代理服务器-windows

- 两台web服务器
  - 一台master: 182.168.80.110
  - 一台node1: 192.168.80.111

hosts文件修改：

```shell
127.0.0.1 master.com
127.0.0.1 node.com
```

配置文件修改：

```shell
	#设置反向代理
	upstream master.test {
	    server 182.168.80.110:80;
	}
	
    upstream node.test {
	    server 182.168.80.111:80;
	}
	#需要代理的服务器信息
	#master 192.168.80.110
	#node 192.168.80.111
	
	server{
	    #监听的端口
		listen 80;
		#通过什么域名访问web服务器
		server_name master.com;
		location / {
		    #设置代理
			proxy_pass http://master.test
		}
	}
	
	server{
	    #监听的端口
		listen 80;
		#通过什么域名访问web服务器
		server_name node.com;
		location / {
		    #设置代理
			proxy_pass http://node.test
		}
	}
```

### 负载均衡设置

hosts文件配置：

```shell
127.0.0.1 testnginx.com
```

设置配置文件：

```shell
	#设置反向代理和负载均衡
	upstream linux.test {
	    server 192.168.80.110:80;
		server 192.168.80.111:80;
	}
	

	#需要代理的服务器信息
	#master 192.168.80.110
	#node 192.168.80.111
	
	server{
	    #监听的端口
		listen 80;
		#通过什么域名访问web服务器
		server_name testnginx.com;
		location / {
		    #设置代理
			proxy_pass http://linux.test;
		}
	}
```

重启nginx。一定要将之前的nginx关闭，然后重启。注意，去任务管理器查看一下是否还有nginx进程。

负载均衡还可以设置权重，如下：

```shell
	#设置反向代理和负载均衡
	upstream linux.test {
	    server 192.168.80.110:80 weight=5; #weight设置权重
		server 192.168.80.111:80 weight=1;
	}
```

反向代理步骤：

- 通过浏览器访问server模块中的server_name对应的域名
- 服务器去找location /
- 需要在里面设置代理：proxy_pass url;
  - url可以自己编一个
- 通过这个url的名字去找upstream模块
- 找到之后，去访问该模块中server对应的地址

负载均衡是在反向代理基础上实现的：

- 入口：server模块里面的server_name对应的域名
- 进入到location /
  - 发现是一个代理：里面有proxy_pass + url
- 通过这个url的名字去找upstream
  - 所有的web服务器的ip都在一个upstream里面
  - 默认情况下处理请求的机会均等。
  - 也可以设置权重：
    - weight=1;
    - 最小值为1
    - 最大值没有上限

nginx无法处理动态数据，比如登陆，注册。这时候nginx需要调用第三方模块去处理。

这个时候可以采用CGI。程序员调用CGI的接口完成数据处理。浏览器调用CGI，就要涉及到HTTP协议。

## CGI

CGI：公共网关接口，Common Gateway Inerface，简称CGI。

在物理层面上是一段程序，运行在服务器上，提供同客户端HTML页面的接口。

CGI程序如何工作的：

- web服务器，收到一个请求
- web服务器fork一个子进程
  - 每处理一个请求，都会创建一个子进程
- 数据处理完成之后，该CGI进程会被web服务器杀死

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190906182544.png)

CGI的缺点：

- 需要频繁的创建进程
- web服务器效率低

改进：

- 使用FASTCGI

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190906183617.png)

## FastCGI

FastCGI是语言无关的，可伸缩架构的CGI开放扩展。其主要行为是将CGI解释器进程保持在内存中进行管理调度，因此获得较高的性能。

FastCGI的工作原理：

- Web server启动时载入FastCGI进程管理器
- FastCGI进程管理器自身初始化，启动拖个CGI解释器进程并等待来自Web Server的连接
- 当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器
- FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server

悲剧的事情：

- nginx下FastCGI与服务器是分离的
- FastCGI可使用spawn-fcgi或者php-fpm来管理

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190906185737.png)

### FastCGI安装

FCGI安装：

```shell
#下载FCGI
git clone https://github.com/sknown/fcgi.git
cd fcgi
#安装
./configure
make install

```

spawn-fcgi安装：

```shell
#下载spawn-fcgi
wget http://download.lighttpd.net/spawn-fcgi/releases-1.6.x/spawn-fcgi-1.6.4.tar.gz
#解压
tar zxvf spawn-fcgi-1.6.4.tar.gz
cd spawn-fcgi-1.6.4
#安装
./configure
make install
```

### spawn-fcgi

spwan-fcgi是一个代理工作，完成nginx和fastcgi之间的进程间通信。

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190906191811.png)

- nginx将数据发给指定端口
- spawn-fcgi收到数据后，查看是否有fastCGI处理该请求，如果没有就fork一个fastCGI来处理该请求，否则直接将数据发送给存在的fastCGI
- fastCGI处理请求，并回应请求
- spawn-fcgi收到响应，就转发给nginx

fastCGI是spawn-fcgi的子进程。spawn-fcgi就可以重定向fastcgi的标准输出到管道的写段。spawn-fcgi直接读管道，然后发送给nginx。

## nginx配置FastCGI

将nginx无法处理的请求，交给FastCGI，即将数据转发到对应端口。

nginx配置文件修改：

```shell
        #处理一个指令test
        # url: http://192.168.80.110/test
        location /test {
             #配置FASTCGI模块
             fastcgi_pass 127.0.0.1:9001;#localhost:90001, 192.168.80.110:90001(本地真实IP)
             #一个端口对应一个进程，将要处理的数据发送到9001端口，然后将9001端口绑定到spawn-fcgi
             include fastcgi.conf; 
        }


```

spawn-fcgi的使用：

- 编写一个fcgi程序，编译出来的程序名为test
- 启动程序

```shell
spawn-fcgi -a IP -p Port -f fastcgi-程序
#IP：服务器IP，这里的IP要跟nginx配置文件中对应
#Port:服务器将数据发送到的端口
#fastcgi-程序:spawn-fcgi启动的可执行fastcgi程序
```

这里我们以源码中给出的example来演示，编译`fcgi/examples/echo.c`文件得到test文件，echo.c实现的功能是将请求的信息打印出来。

```shell
gcc echo.c -lfgci -o test #需要加上fcgi动态库
```

启动程序出错:

```shell
[root@k8s-node1 spawn-fcgi-1.6.4]# spawn-fcgi -a 127.0.0.1 -p 9001 -f ./test
spawn-fcgi: child exited with: 127
[root@k8s-node1 spawn-fcgi-1.6.4]# spawn-fcgi -a 127.0.0.1 -p 9001 -f ./test -n
sh: /root/download/spawn-fcgi-1.6.4/test: No such file or directory
[root@k8s-node1 spawn-fcgi-1.6.4]# cd ..
[root@k8s-node1 download]# cd ..
[root@k8s-node1 ~]# spawn-fcgi -a 127.0.0.1 -p 9001 -f ./test -n
./test: error while loading shared libraries: libfcgi.so.0: cannot open shared object file: No such file or directory
[root@k8s-node1 ~]# find / -name  libfcgi.so.0
/root/download/fcgi/libfcgi/.libs/libfcgi.so.0
/usr/lib/libfcgi.so.0
/usr/local/lib/libfcgi.so.0
[root@k8s-node1 ~]# vi /etc/ld.so.conf #在文件末尾添加： /usr/local/lib
[root@k8s-node1 ~]# ldconfig
[root@k8s-node1 ~]# spawn-fcgi -a 127.0.0.1 -p 9001 -f ./test
spawn-fcgi: child spawned successfully: PID: 127212
```

如果启动程序错误，可以添加`-n`来查看错误信息。上面出错是由于找不到动态文件。

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190907084755.png)

上面是直接在地址栏输入地址带参数，这属于get请求，下面我们测试一下post请求。

首先，编写一个简单的html文件：

```html
<html>
<head>
hello
</head>
<body>

<form method="post" action="http://192.168.80.110/test">

	<p><label>姓名：<input type="text" name="username" placeholder="贵姓" autofocus="autofocus"></label></p>
	<p><label>电话：<input type="tel" name="phone" placeholder="号码" required="required"></label></p>
	<input type="submit" value="Submit" />
<form>
    
</body>
</html>

```

在浏览器中打开该文件，在输入框中输入姓名和电话。点击提交。页面跳转到如下界面：

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190907090814.png)

### FastCGI

环境变量指针：

`extern char **__environ`

FCGI_Accept()

fastcgi.conf中常用环境变量：

- QUERY_STRING: 请求的资源，get请求行的第二部分
- REQUEST_METHOD：请求方法，get/post

##  部署Web实现文件上传操作

web代码可以去我的csdn博客下载：https://download.csdn.net/download/qq_25774883/11692288

或者见这篇博客：https://www.codetd.com/article/5307804

部署流程：

- 将zyFile2拷贝到nginx安装目录：`usr/local/nginx`

- 查看上传文件对应的html，找到数据提交的位置(nginx需要配置的指令`/upload/UploadAction`)

- 修改nginx配置文件，添加一个location

  ```shell
          #处理文件上传
          location /upload/UploadAction {
               fastcgi_pass 127.0.0.1:9002;
               include fastcgi.conf;
        }
  ```

- 重新加载配置文件`nginx -s reload`
- 编写一个fastcgi程序
  - 将上传文件的内容保存到FASTDFS存储节点
    - 先将上传文件内存保存到web服务器
    - 调用FASTDFS API将文件上传到FASTDFS存储节点上，并返回文件ID
    - 得到文件ID，将文件名和文件ID存储到mysql数据库中
    - 将上传的文件从web服务器中删除

## Post提交数据的四种方式

HTTP概述：

- HTTP请求分为四个部分:状态行、请求头、空行消息、主体。

- 协议规定POST提交的数据必须放在消息主题(entity-body)中，但协议并没有规定数据必须使用什么编码格式。

- 开发者完全可以自己决定消息主题的格式。
- 数据发送出去，还要服务端解析成功才有意义，服务端通常是根据请求头(headers)中的Content-type字段来获知请求中的消息主题是用何种方式编码，再对主体 进行解析。

四种方式：

- application/w-www-form-urlencoded

  ```shell
  Content-Type: application/x-www-form-urlencoded
  username=111&phone=2222
  ```

- application/json

  ```shell
  Content-Type: application/json
  {"title": "test", "sub":[1,2,3]}
  ```

- text/xml

  ```shell
  Content-Type: text/xml
  <!--?xml version="1.0" ?-->
  ```

- multipart/form-data

## 文件下载

用户下载文件的流程：

- 浏览器访问web服务器
- web服务器调用cgi程序
- cgi程序需要访问tracker
- tracker会提供storage的ip和端口
- cgi程序，去访问storage，下载数据
- web服务器需要再次将数据发给浏览器

改进下载流程：

- 通过浏览器访问web服务器
- 拿到一个地址，直接通过这个地址来访问storage上的图片

如何实现改进下载流程：

- 有一个storage服务器
  - 在上边部署一个nginx服务器
  - 需要在nginx中添加一个fastdfs模块

**第一步**：安装nginx：再fastdfs的storage服务器上安装

**第二步：**安装`fastdfs-nginx-module`：

模块下载地址： http://pan.baidu.com/s/1hs3qp84

下载后上传到linux主机上。

fastdfs-nginx-module_v1.16源码包目录结构：

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190907215754.png)

```shell
tar xzvf fastdfs-nginx-module_v1.16.tar.gz
./configure --add-module=/root/download/fastdfs-nginx-module/src #后面的路径是解压后得到的文件路径
#make，如果发现报错，显示找不到某个头文件，就通过find查找该头文件，将该目录添加到Makefile中的头文件部分
#注意，应该是objs目录下的Makefile
[root@k8s-master ~]# find / -name fdfs_define.h
/root/download/FastDFS/common/fdfs_define.h
/usr/include/fastdfs/fdfs_define.h
[root@k8s-master ~]# find /usr/include -name common_define.h
/usr/include/fastcommon/common_define.h
[root@k8s-master nginx-1.10.1]# ls
auto  CHANGES  CHANGES.ru  conf  configure  contrib  html  LICENSE  Makefile  man  objs  README  src
[root@k8s-master nginx-1.10.1]# cd objs
[root@k8s-master objs]# vim Makefile 
#添加最后面两行
ALL_INCS = -I src/core \
        -I src/event \
        -I src/event/modules \
        -I src/os/unix \
        -I /usr/local/include/fastdfs \
        -I /usr/local/include/fastcommon/ \
        -I objs \
        -I src/http \
        -I src/http/modules \
        -I /usr/include/fastdfs \
        -I /usr/include/fastcommon
[root@k8s-master nginx-1.10.1]# make install

```

重新启动nginx:

```shell
nginx -s stop
nginx
#查询nginx进程启动情况
[root@k8s-master sbin]# ps aux | grep nginx
root     117083  0.0  0.0  27816   680 ?        Ss   08:53   0:00 nginx: master process nginx
root     117088  0.0  0.0 110276   912 pts/4    R+   08:53   0:00 grep --color=auto nginx

```

发现只有master进程启动了，worker进程没有启动。这个时候我们进入nginx/logs目录下，查看error.log日志。

```shell
[root@k8s-master logs]# ls
access.log  error.log  nginx.pid
[root@k8s-master logs]# cat error.log 
#省略部分日志，直接查看末尾的错误信息
ngx_http_fastdfs_process_init pid=117084
[2019-09-07 08:53:14] ERROR - file: shared_func.c, line: 1067, file /etc/fdfs/mod_fastdfs.conf not exist
[2019-09-07 08:53:14] ERROR - file: /root/download/fastdfs-nginx-module/src/common.c, line: 155, load conf file "/etc/fdfs/mod_fastdfs.conf" fail, ret code: 2
2019/09/07 08:53:14 [alert] 117083#0: worker process 117084 exited with fatal code 2 and cannot be respawned
```

发现是因为再/etc/fdfs目录下找不到mod_fastdfs.conf配置文件。然后我们通过查找该文件并拷贝到该目录下：

```shell
 cp /root/download/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/ #第一个路径为我们下载fastdfs-nginx-module包中一个src路径下的一个配置文件
```

然后，对配置文件进行修改（**参照存储节点的配置文件修改，也在/etc/fdfs目录下**）：

```shell
# the base path to store log files
base_path=/root/fdfs/storage #storage日志的位置

# FastDFS tracker_server can ocur more than once, and tracker_server format is
#  "host:port", host can be hostname or ip address
# valid only when load_fdfs_parameters_from_tracker is true
tracker_server=192.168.80.110:22122  #追踪器地址

# the port of the local storage server
# the default value is 23000
storage_server_port=23000 #跟存储节点端口对应

# the group name of the local storage server
group_name=group1  #当前存储节点所属的组

# if the url / uri including the group name
# set to false when uri like /M00/00/00/xxx
# set to true when uri like ${group_name}/M00/00/00/xxx, such as group1/M00/xxx
# default value is false
url_have_group_name = true  #默认为false，不显示组名

# path(disk or mount point) count, default value is 1
# must same as storage.conf
store_path_count=1  #跟storage对应

# store_path#, based 0, if store_path0 not exists, it's value is base_path
# the paths must be exist
# must same as storage.conf
store_path0=/root/fdfs/storage   #跟storage对应，如果有多个，需要全部卸载配置文件中 store_path1...

# set the group count
# set to none zero to support multi-group
# set to 0  for single group only
# groups settings section as [group1], [group2], ..., [groupN]
# default value is 0
# since v1.14
group_count = 1 #整个FastDFS文件系统一共有多少个组

#除去注释
# group settings for group #1
# since v1.14
# when support multi-group, uncomment following section
[group1]
group_name=group1
storage_server_port=23000
store_path_count=1
store_path0=/root/fdfs/storage
#store_path1=/home/yuqing/fastdfs1
```

重新启动nginx，发现还是报错了，查看error.log日志：

```shell
ngx_http_fastdfs_process_init pid=118847
[2019-09-07 09:21:47] ERROR - file: ini_file_reader.c, line: 1029, include file "http.conf" not exists, line: "#include http.conf"
[2019-09-07 09:21:47] ERROR - file: /root/download/fastdfs-nginx-module/src/common.c, line: 155, load conf file "/etc/fdfs/mod_fastdfs.conf" fail, ret code: 2
2019/09/07 09:21:47 [alert] 118846#0: worker process 118847 exited with fatal code 2 and cannot be respawned
```

报错信息是：http.conf文件不存在。

解决措施:

- 从FastDFS的源码安装包中的conf中，将http.conf拷贝到/etc/fdfs
- 从nginx的源码安装包中的conf中，将mime.types拷贝到/etc/fdfs

```shell
root@k8s-master FastDFS]# ls
client  conf             fastdfs.spec  init.d   make.sh     README.md   stop.sh  test
common  COPYING-3_0.txt  HISTORY       INSTALL  php_client  restart.sh  storage  tracker
[root@k8s-master FastDFS]# cd conf
[root@k8s-master conf]# ls
anti-steal.jpg  client.conf  http.conf  mime.types  storage.conf  storage_ids.conf  tracker.conf
[root@k8s-master conf]# cp http.conf /etc/fdfs
[root@k8s-master conf]# cd ..
[root@k8s-master FastDFS]# cd ..
[root@k8s-master download]# cd nginx-1.10.1
[root@k8s-master nginx-1.10.1]# ls
auto  CHANGES  CHANGES.ru  conf  configure  contrib  html  LICENSE  Makefile  man  objs  README  src
[root@k8s-master nginx-1.10.1]# cd conf
[root@k8s-master conf]# ls
fastcgi.conf  fastcgi_params  koi-utf  koi-win  mime.types  nginx.conf  scgi_params  uwsgi_params  win-utf
[root@k8s-master conf]# cp mime.types /etc/fdfs
```

重新启动nginx:

```shell
[root@k8s-master nginx]# nginx -s stop
[root@k8s-master nginx]# nginx 
[root@k8s-master nginx]# ps aux | grep nginx
root     119220  0.0  0.0  27816   684 ?        Ss   09:27   0:00 nginx: master process nginx
nobody   119221  0.0  0.1  28348  1892 ?        S    09:27   0:00 nginx: worker process
root     119257  0.0  0.0 110276   908 pts/4    S+   09:28   0:00 grep --color=auto nginx

```

发现两个进程都启动成功了。

配置nginx配置文件：

````shell
        location /group1/M00 {
            root /root/fdfs/storage/data; #fastDFS的storage存储数据的真实目录
            ngx_fastdfs_module;
        }
````

重新启动nginx:

```shell
nginx -s reload
```

注意如果还是存在无法访问，即404 NOT Found。可能是存储的路径没有访问的权限。因为我把storage存储数据的位置放在root目录下，所以默认是无法访问的，所以需要修改root的权限。·

````shell
[root@k8s-master ~]# cd /
[root@k8s-master /]# chmod 777 root
````

## 上传文件服务端CGI程序



# QT

## QT界面搭建

QT窗口的布局：

- 水平布局：QHBoxLayout
- 垂直布局：QVBoxLayout
- 网格布局：QGridLayout

绘制窗口背景图:

- 重写这个类的绘图事件`paintEvent`
- 在这个函数中使用画家类完成绘图操作
  - 指定绘图设备，就是当前的对象：`QPainter p(this);`

鼠标事件的使用：

- `mouseMoveEvent()`
- `mousePressEvent()`

自定义窗口：

- 最终是使用这个自定义类来提升一个基类
- 先看需要提升的类的数据类型(`QPushButton`)
- 自定义的类型需要从`QPUshButton`派生
- 使用自定的子类，完成父类的提升

Qt中样式表的使用：

- 在控件对应的属性窗口中设置
  - QWidget属性-styleSheet
- setStyleSheet();

## 数据校验

正则表达式。

对应的类：`QRegExp`

```C++
QRegExp reg("a*.b");
bool res = reg.exactMatch("aacb");
setPattern("bcdef*b.");
```



## Qt窗口间通信



## QT中使用Json

Json的全称是JavaScritp Object Notation.意思是JavaScritpt对象表示法，它是一个基于文本，独立于语言的轻量级数据交换。

Qt5中新增了处理JSON的累，均以QJson开头，在QtCore模块中，不需要额外引入其他模块。

---

|        类名称         |                   类说明                    |
| :-------------------: | :-----------------------------------------: |
|     QJsonDocument     |                读写Json文档                 |
|      QJsonObject      |                封装JSON对象                 |
|      QJsonArray       |                封装JSON数组                 |
|      QJsonValue       |                 封装JSON值                  |
| QJsonObject::iterator | 用于遍历QJsonObject的STL风格的非const遍历器 |
|    QJsonParseError    |        报告Json处理过程中出现的错误         |

在内存中有一个json格式字符串：

- 首先需要一个QJsonDocument类，将json字符串转为QJsonDocument，利用`fromJson`静态成员函数进行转换。`QJsonDocument::fromJson(str);`
- 调用object()成员函数转换位json对象；
- 调用array()成员函数转换位array对象；
- 利用QJsonDocument类转换为字符串，利用`toJson`函数转换为QByteArray。

示例：

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonValue>
#include <QFile>

#include <QJsonArray>
#include <QDebug>

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    //创建json对象
    QJsonObject obj;
    QJsonObject sub;
    sub.insert("IP", QJsonValue("192.168.80.110"));
    sub.insert("Port", QJsonValue("9000"));
    obj.insert("server",QJsonValue(sub));
    //内存中的Json数据写入文件中
    QJsonDocument doc(obj);
    //将json对象转换为字符串
    QByteArray data = doc.toJson();
    //字符串写入文件
    QFile file("temp.json");
    file.open(QIODevice::WriteOnly);
    file.write(data);
    file.close();

    QFile file("temp.json");
    file.open(QIODevice::ReadOnly);
    QByteArray data = file.readAll();
    file.close();
    //使用josn文件加载json对象
    QJsonDocument doc = QJsonDocument::fromJson(data);
    //判断数组还是对象
    if(doc.isObject()){
        QJsonObject obj = doc.object();
        QJsonValue value = obj.value("server");
        if (value.isObject()){
            QJsonObject subObj = value.toObject();
            //取值
            QString ip = subObj.value("IP").toString();
            QString port = subObj.value("Port").toString();
            qDebug() << ip << port;
         }
    }

    //Json数组
    QJsonArray arr;
    arr.push_back(QJsonValue(QString("ii")));
    arr.push_back(QJsonValue(QString("jj")));
    QJsonObject obj;
    obj.insert("IP", QJsonValue("192.168.80.110"));
    obj.insert("arr", QJsonValue(arr));
    QJsonDocument doc(obj);
    //将json对象转换为字符串
    QByteArray data = doc.toJson();
    //字符串写入文件
    QFile file("array.json");
    file.open(QIODevice::WriteOnly);
    file.write(data);
    file.close();

    QFile file("array.json");
    file.open(QIODevice::ReadOnly);
    QByteArray data = file.readAll();
    file.close();
    //使用josn文件加载json对象
    QJsonDocument doc = QJsonDocument::fromJson(data);
    //判断数组还是对象
    if(doc.isObject()){
        QJsonObject obj = doc.object();
        QJsonValue value = obj.value("arr");
        if (value.isArray()){
            QJsonArray array = value.toArray();
            QString str1 = array[0].toString();
            QString str2 = array[1].toString();
            qDebug() << str1 << str2;
        }
    }

}

MainWindow::~MainWindow()
{
    delete ui;
}

```



## QT中使用HTTP协议通信

`QNetworkAccessManager`类允许应用程序发送网络请求和接收网络应答。

Network Access API都是围绕着一个`QNetworkAccessManager`对象构造的，这个对象包含着发送请求的一些通用配置和设置。它包含着代理和缓存的配置，以及和这些事物相关的一些信号，并且应答信号可以作为我们检测一个网络操作的进度。

一个`QNetworkAccessManager`对于一整个Qt应用程序来时已经足够了！

一旦一个`QNetworkManager`对象被创建了，那么应用程序就可以使用它在网络上发送请求。它提供了一组标准的函数，可以承载网络请求和一些可选的数据，并且每一个请求返回一个`QNetworkReply`对象。该返回的堆叠包含着返回的请求应带的所有数据。

### `QNetworkAccessManager`类

`QNetworkAccessManager`将会把它收到的请求排队，并行执行的请求数量是依赖于协议的。

目前，对于桌面拍拖的HTTP协议，对于一个主机/端口的组合，可6个请求并行执行。

发送请求：

- get
- post

### `QNetworkRequest`类

Network Access API的一部分，并且这个类包含着在网络上发送请求的必要信息。

- 它包含了一个URL和一些可以用来修改请求的附加信息。
- 将需要发送的HTTP请求协议初始化到该类中
  - 请求头
  - 数据
  - URL

### `QNetworkReply`类

`QNetworkAccessManager`返回的一个对象，请求完成之后，需要删除该对象。

通过该对象，读取服务器返回的数据。

捕捉信号：

- readyRead()
- finished();

读取数据：readall()

以上所有类都属于network模块，需要在pro文件中添加network模块。

```c++
QT       += core gui network
```



示例：

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"

#include <QDebug>
#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QNetworkRequest>

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    //HTTP通信
    //需要一个manager对象，执行get或post请求
    //整个项目中一个QNetworkAccessManager对象就可以了
    QNetworkAccessManager * manager = new QNetworkAccessManager(this); //this表示，当前窗口结束时，释放创建的对象

    //准备工作 --初始化一个QNetworkRequest对象
    QNetworkRequest res;
    //设置头
    QString head = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36";
    res.setHeader(QNetworkRequest::UserAgentHeader, head);
    res.setUrl(QUrl("http://www.baidu.com:80"));
    //发起Post请求
   // QNetworkReply * reply =  manager->post(res, ""); //数据为空
   //发起Get请求
    QNetworkReply * reply =  manager->get(res); //数据为空

    //读取服务器回写的数据
    //QT中ssl库找不到的问题解决:https://www.cnblogs.com/zwj412/p/10352375.html
    connect(reply, &QNetworkReply::finished, this, [=]{
         //服务器响应的信息，不包括头部信息
        QByteArray data = reply->readAll();
        QVariant str = reply->header(QNetworkRequest::LocationHeader); //获取重定向信息
        qDebug() << str.toString();
        qDebug() << data;
    });
}

MainWindow::~MainWindow()
{
    delete ui;
}
```

## Mysql数据库表

```mysql
CREATE DATABASE cloud_disk;

use cloud_disk;

#user表
CREATE TABLE user(
	id BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR (128) NOT NULL,
    nickname VARCHAR(128) NOT NULL,
    password VARCHAR(128) NOT NULL,
    phone VARCHAR(15) NOT NULL,
    createtime VARCHAR(128),
    email VARCHAR(100),
    CONSTRAINT uq_nickname UNIQUE (nickname), #nickname必须唯一
    CONSTRAINT uq_name UNIQUE(name) #name必须唯一
);

INSERT INTO user(name, nickname, password, phone, createtime, email)
VALUES('mike', 'sh', '123456', '10086', '2017-01-11 17:45:40', '110909@qq.com');

SELECT id FROM user WHERE name = 'mike';

#file_info表
CREATE TABLE file_info(
	md5 VARCHAR(200) NOT NULL PRIMARY KEY,
    file_id VARCHAR(256) NOT NULL,
    url VARCHAR(512) NOT NULL, #图片的URL
    size BIGINT, #文件大小
    type VARCHAR(20), #文件类型 png,zip...
    count INT #被多少个用户拥有
);

UPDATE file_info SET count=2 WHERE md5 = "bas3iujlkfjdjsaifjd89758uidjf...";

#用户文件列表 user_file_list
CREATE TABLE user_file_list(
	user VARCHAR(128) NOT NULL,
    md5 VARCHAR(200) NOT NULL,
    createtime VARCHAR(128),
    filename VARCHAR(128),
    shared_status INT, #共享状态，0为没有共享，1为共享
    pv INT #文件下载量，默认值为0，下载一次加1
);

#查找某个用户的文件列表
SELECT md5 FROM user_file_list WHERE name = 'mike';

#查看某个文件的属性
SELECT * FROM file_info WHERE md5 ="ddddddd";

#设置某个文件是否共享
UPDATE user_file_list SET shared_status = 1 WHERE md5="dddddd" AND user = 'mike';

#用户文件数量表 user_file_count
CREATE TABLE user_file_count(
	user VARCHAR(128) NOT NULL PRIMARY KEY,
    count INT
);

#文件共享列表 share_file_list
CREATE TABLE share_file_list(
	user VARCHAR(128) NOT NULL,
    md5 VARCHAR(200) NOT NULL,
    createtime VARCHAR(128),
    filename VARCHAR(128),
    pv INT#文件下载量，默认值为1，下载一次加1
);
```





## MD5

Message Digest Algorith5 (信息摘要算法5)

MD5算法具有的特点：

- 压缩性：
  - 任意长度的数据，算出的MD5值长度都是固定的
  - 把一个任意长度的字符串变换成一个定长的十六进制数字串

- 容易计算

  从原数据计算MD5值很容易

- 抗修改性

  对原数据进行任何改动，所得到的MD5值都有很大的区别。

- 强抗碰撞性

  已知原数据和其MD5值，想找到一个具有相同MD5值的数据是非常困难的。

- MD5过程是不可逆的

MD5的应用：

- 文件校验：文件下载站、论坛数据块、文件系统安全等方案
- 数字证书
  - 互联网通讯中标志通信各方身份信息的一串数字
  - 提供了一种在Internet上验证通信实体身份的方式
- 登陆验证：操作系统的登陆认值，如Unix，各类DSB系统登陆密码

MD5算法描述：

- MD5就是将输入的信息以512位分组，且每一分组被划分位16个32位子分组
- 经过了一系列的处理后，算法的输出由四个32位分组组成，将这4个32位分组级联后得到一个128位散列值。

## QT中使用MD5

`QCryptographicHash`

```C++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QDebug>
#include <QCryptographicHash>

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);

#if 0
    //MD5
    QByteArray data = "hello world";
    QCryptographicHash hash(QCryptographicHash::Md5);
    //添加数据
    hash.addData(data);
    //计算
    QByteArray arr = hash.result();
    qDebug() << arr;
    arr = arr.toHex();
    qDebug() << arr;
#else
    QByteArray arr = QCryptographicHash::hash("hello world", QCryptographicHash::Md5);
    qDebug() << arr.toHex();
# endif
}

MainWindow::~MainWindow()
{
    delete ui;
}

```

## Base64

Base64是一种用64个字符来表示任意二进制数据的方法

[‘A’, 'B', ...., 'Z', 'a', 'b', ..., 'z', '0',...,'9','+','/']

为什么要用Base64编码？

- 在网络上交换数据时，比如说从A地传到B地，往往要经过多个路由设备，由于不同的设备对字符串的处理方式有些不同，这样那些不可见字符就可能被处理错误，这是不利于传输的。
- 把数据先做一个Base64编码，统统变成可见字符，这样出错的可能性就大大降低了
- 很多场景下的数据传输要求数据只能由简单通用的字符组成，比如HTTP协议要求请求的首行和请求头都必须由ASCII编码。
- 能对文本进行简单的加密

算法描述：

- 把3个8位字节转化位4个6位的字节
- 把6位的前面补两个0，形成8位一个字节的形式
- 如果剩下的字符不足3个字节，则用0填充，输出字符使用‘=’，因此编码后输出的文本末尾可能出现1或2个‘=’，表示补了多少个字节，解码的时候，会自动去掉

## QT中使用Base64

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QDebug>

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    //Base64编码
    QByteArray base = "你好，世界";
    base = base.toBase64();
    qDebug() << base;
    //解码
    base = QByteArray::fromBase64(base); //静态成员函数
    qDebug() << base.data();

}

MainWindow::~MainWindow()
{
    delete ui;
}
```

# 协议设计

文件上传

![](https://raw.githubusercontent.com/zxpgo/images/master/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.jpg)

文件列表获取：

![](https://raw.githubusercontent.com/zxpgo/images/master/img/%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8%E8%8E%B7%E5%8F%96.jpg)

文件下载：

![](https://raw.githubusercontent.com/zxpgo/images/master/img/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%20(1).jpg)







注册代码实现：`reg_cgi.c`

```c
#include "fcgi_config.h"
#include "fcgi_stdio.h"
#include "cJSON.h"
#include <mysql/mysql.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifdef _WIN32
#include <process.h>
#else
extern char **environ;
#endif


#define SQL_MAX_LEN 1024

MYSQL* mysql_conn(char* g_user_name, char* g_password, char* g_db_name){
	MYSQL* g_conn;
	g_conn = mysql_init(NULL);
	/*设置字符编码,可能会乱码*/
	//mysql_query(g_conn, "set nemas utf-8");
	/* connect the database */
	//暂时直接设置ip和端口，后面放到配置文件中
	const char *g_host_name = "192.168.80.110";
	const unsigned int g_db_port = 3306;
	mysql_real_connect(g_conn, g_host_name, g_user_name, g_password, g_db_name, g_db_port, NULL, 0); // 如果失败
	return g_conn;
}

int process_result_one(MYSQL* conn, char* sql_cmd, char* buf)
{
	int ret = 0;
	MYSQL_RES * res_set = NULL; //结果集结构的指针
	 
	if (mysql_query(conn, sql_cmd) != 0)
	{
		//print_error(conn, "mysql_query error!\n");
		ret = -1;
		goto END;
	}
	
	res_set = mysql_store_result(conn); //生成结果集
	if (NULL == res_set)
	{
		//print_error(conn, "mysql_store_result error!\n");
		ret = -1;
		goto END;
	}
	
	MYSQL_ROW row;
	ulong line = 0;
	
	//mysql_num_rows接受由mysql_share_result返回的结果结果集，并返回结构集中的行数
	line = mysql_num_rows(res_set);
	if (line == 0){
		ret = 1; //没有记录集
		goto END;
	}
	else if(line > 0 && buf == NULL) //如果buf为null，无需保存结果集，只做判断有没有此记录
	{
		ret = 2;//2有记录但是没有保存
		goto END;
	}
	
	//mysql_fetch_row从结果结构中提取一行，并把它放到一个行结构中，当数据用完或发生错误时返回NULL
	if ((row = mysql_fetch_row(res_set)) != NULL)
	{
		if (row[0] != NULL)
		{
			strcpy(buf,row[0]);
		}
	}
	
END:

	if(res_set != NULL)
	{
		//完成所有对数据的操作后，调用mysql_free_result来善后处理
		mysql_free_result(res_set);
	}
	
	return ret;
	
}


char * return_status(char * status_num)
{
	char * out = NULL;
	cJSON * root = cJSON_CreateObject(); //创建json项目
	cJSON_AddStringToObject(root, "code", status_num); //{"code","003"}
	out = cJSON_Print(root);  //cJSON to char *
	
	cJSON_Delete(root);
	
	return out;
}

int get_reg_info(char* reg_buf, char* user, char* nick_name, char* pwd, char* tel, char* email)
{
	
	int ret = 0;
	/*
	{
		userName: xxx
		nickName: xxx	
		firstPwd: xxx
		phone: xxx
		email: xxx
	}	
	*/
	//解析json包
	//解析一个json字符串为cJson对象
	cJSON  * root = cJSON_Parse(reg_buf);
	if (NULL == root)
	{
		ret = -1;

	}
	
	//返回指定字符串对象的json对象
	//用户
	cJSON * child1 = cJSON_GetObjectItem(root, "userName");
	if (NULL == child1){
		ret = -1;

	}

	strcpy(user, child1->valuestring); //拷贝内容

	cJSON * child2 = cJSON_GetObjectItem(root, "nickName");
	if (NULL == child2)
	{
		ret = -1;

	}
	strcpy(nick_name, child2->valuestring);

	cJSON * child3 = cJSON_GetObjectItem(root, "firstPwd");
	if (NULL == child3)
	{
		ret = -1;

	}
	strcpy(pwd, child3->valuestring);

	cJSON * child4 = cJSON_GetObjectItem(root, "phone");
	if (NULL == child4)
	{
		ret = -1;

	}
	strcpy(tel, child4->valuestring);

	cJSON * child5 = cJSON_GetObjectItem(root, "email");
	if (NULL == child5)
	{
		ret = -1;

	}
	strcpy(email, child5->valuestring);

	
	if (root != NULL)
	{
		cJSON_Delete(root); //删除json对象
		
	}
	return ret;
}
/*
分为三步：
将客户端发送过来的数据进行解析，获取用户名、密码等信息
判断表user中是否存在该记录
如果不存在，将数据插入数据库
*/

int user_register(char * reg_buf)
{
	int ret = 0;
	MYSQL * conn = NULL;
	
	//获取数据库用户名，用户密码，数据库标示等信息
	char mysql_user[256] = "root";
	char mysql_pwd[256] = "zxcvfdsa321";
	char mysql_db[256] = "cloud_disk";
	
	//ret = get_mysql_info(mysql_user, mysql_pwd, mysql_db);
	if (ret != 0){
		goto END;
	}
	
	//获取用户信息
	char user[128];
	char nick_name[128];
	char pwd[128];
	char tel[128];
	char email[128];

	ret = get_reg_info(reg_buf, user, nick_name, pwd, tel, email);

	//printf("%s,%s,%s,%s,%s",user, nick_name, pwd, tel, email);

	
	if (0 != ret)
	{
		ret = -1;
		goto END;
	}
	
	//连接数据库
	conn = mysql_conn(mysql_user, mysql_pwd, mysql_db);
	if (NULL == conn)
	{
		ret = -1;
		goto END;
	}
	
	//设置数据库密码，注意处理中文编码问题
	mysql_query(conn, "set names utf8");
	
	char sql_cmd[SQL_MAX_LEN] = {0};
	
	sprintf(sql_cmd, "select * from user where name = '%s'", user);
	
	//查看用户是否存在
	int ret2 = 0;
	//返回值： 0成功并保存记录，1没有记录，2有记录但是没有保存， -1失败
	ret2 = process_result_one(conn, sql_cmd, NULL);
	if (ret2 == 2) //如果存在
	{
		ret = -2;
		goto END;
	}

	//当前时间戳
	time_t tv;
	struct tm* ptm;
	char time_str[128] = "2019/9/25 21:27:12";
	/*
	//使用行数gettimeofday()函数来得到时间，它的精度可以达到微妙
	time(&tv);
	ptm = localtime(&tv); //把1970-1-1零点零分当作时间系统所偏移的秒数时间转换为本地时间
	//strftime()函数根据区域设置格式本地时间/日期，函数的功能将时间格式化，或者说格式化一个时间字符串
	printf("%ld\n", tv);
	strftime(time_str, sizeof(time_str), "%Y/%m/%d %H:%M:%S", ptm);
	*/
	//sql语句，插入注册信息
	sprintf(sql_cmd, "insert into user (name, nickname, password, phone, createtime, email) \
	values('%s', '%s','%s','%s','%s','%s')", user, nick_name, pwd, tel, time_str, email);
	
	if (mysql_query(conn, sql_cmd) != 0)
	{
		ret = -1;
		goto END;
	}
	
END:
	
	if (conn != NULL)
	{
		mysql_close(conn); //断开数据库连接
	}
	
	return ret;
}



int main ()
{


    int count = 0;

    while (FCGI_Accept() >= 0) {
        char *contentLength = getenv("CONTENT_LENGTH");
        int len;

	printf("Content-type: text/html\r\n"
	    "\r\n"
	    );

        if (contentLength != NULL) {
            len = strtol(contentLength, NULL, 10);
        }
        else {
            len = 0;
        }

        if (len <= 0) {
	    printf("No data from standard input.<p>\n");
        }
        else {
			char buf[4*1024];
            int i, ch;
			int ret = 0;
			char * out;

	    //printf("Standard input:<br>\n<pre>\n");
            for (i = 0; i < len; i++) {
                if ((ch = getchar()) < 0) {
                    printf("Error: Not enough bytes received on standard input<p>\n");
                    break;
			}
                buf[i] = ch;
            }
			//printf("%s",buf);
			/*
			注册：
				成功：{"code": "002"}
				该用户已存在：{"code": "003"}
				失败：{"code": "004"}
			*/
			
			ret = user_register(buf);
			if (ret ==0)//注册成功
			{
				//返回前端注册情况，002代表成功
				out = return_status("002");
			}
			else if (ret == -1)
			{
				//返回当前注册情况，004代表失败
				out = return_status("004");
			}
			else if (ret == -2)
			{
				out = return_status("003");
			}
			
			if (out != NULL)
			{
				printf(out); //给前端反馈信息
				free(out);
			}
            //printf("\n</pre><p>\n");
        }


    } /* while */

    return 0;
}
```

fastcgi配置：

```shell
 gcc reg_cgi.c  -o reg_cgi -lcJson -lmysqlclient -lfcgi
 spawn-fcgi -a 127.0.0.1 -p 10001 -f ./reg_cgi
```

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190926104335.png)

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190926104414.png)

登陆代码实现：`login_cgi.c`

```c
#include "fcgi_config.h"
#include "fcgi_stdio.h"
#include "cJSON.h"
#include <mysql/mysql.h>
#include <stdio.h>
#include <stdlib.h>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifdef _WIN32
#include <process.h>
#else
extern char **environ;
#endif


#define SQL_MAX_LEN 1024


MYSQL* mysql_conn(char* g_user_name, char* g_password, char* g_db_name){
	MYSQL* g_conn;
	g_conn = mysql_init(NULL);
	/*设置字符编码,可能会乱码*/
	//mysql_query(g_conn, "set nemas utf-8");
	/* connect the database */
	//暂时直接设置ip和端口，后面放到配置文件中
	const char *g_host_name = "192.168.80.110";
	const unsigned int g_db_port = 3306;
	mysql_real_connect(g_conn, g_host_name, g_user_name, g_password, g_db_name, g_db_port, NULL, 0); // 如果失败
	return g_conn;
}


char * return_status(char * status_num)
{
	char * out = NULL;
	cJSON * root = cJSON_CreateObject(); //创建json项目
	cJSON_AddStringToObject(root, "code", status_num); //{"code","003"}
	out = cJSON_Print(root);  //cJSON to char *
	
	cJSON_Delete(root);
	
	return out;
}

int get_login_info(char* login_buf, char* user, char* pwd)
{
	
	int ret = 0;
	/*
	{
		user: xxx
		pwd: xxx
	}	
	*/
	//解析json包
	//解析一个json字符串为cJson对象
	cJSON  * root = cJSON_Parse(login_buf);
	if (NULL == root)
	{
		ret = -1;

	}
	//返回指定字符串对象的json对象
	//用户
	cJSON * child1 = cJSON_GetObjectItem(root, "user");
	if (NULL == child1){
		ret = -1;
		goto END;
	}
	strcpy(user, child1->valuestring); //拷贝内容

	//密码
	cJSON * child2 = cJSON_GetObjectItem(root, "pwd");
	if (NULL == child2)
	{
		ret = -1;
		goto END;
	}
	strcpy(pwd, child2->valuestring);

END:
	
	if (root != NULL)
	{
		cJSON_Delete(root); //删除json对象
		root = NULL;
	}
	return ret;
}

int process_result_one(MYSQL* conn, char* sql_cmd, char* pwd)
{
	int ret = 0;
	
	MYSQL_RES * res_set = NULL; //结果集结构的指针
	 
	if (mysql_query(conn, sql_cmd) != 0)
	{
		//print_error(conn, "mysql_query error!\n");
		ret = -1;
		goto END;
	}
	
	res_set = mysql_store_result(conn); //生成结果集
	if (NULL == res_set)
	{
		//print_error(conn, "mysql_store_result error!\n");
		ret = -1;
		goto END;
	}
	
	MYSQL_ROW row;
	ulong line = 0;
	//mysql_num_rows接受由mysql_share_result返回的结果结果集，并返回结果集中的行数
	line = mysql_num_rows(res_set);
	//printf("line = %d \n", line);
	if (line == 0 || pwd == NULL){
		ret = -1; //没有记录集,或者密码为空
		goto END;
	}

	row = mysql_fetch_row(res_set);

	if (strcmp(pwd, row[0]) != 0)
		ret = -1;
	//mysql_fetch_row从结果结构中提取一行，并把它放到一个行结构中，当数据用完或发生错误时返回NULL
	/*
	if ((row = mysql_fetch_row(res_set)) != NULL)
	{
		if (row[0] != NULL)
		{
			strcpy(buf,row[0]);
		}
	}
	printf("%s\n", buf);
	*/
END:

	if(res_set != NULL)
	{
		//完成所有对数据的操作后，调用mysql_free_result来善后处理
		mysql_free_result(res_set);
	}
	
	return ret;
	
}

/*
分为两步：
将客户端发送过来的数据进行解析，获取用户名、密码
判断表user中是否存在该记录
*/

int user_login(char * reg_buf)
{
	int ret = 0;
	MYSQL * conn = NULL;
	
	//获取数据库用户名，用户密码，数据库标示等信息
	char mysql_user[256] = "root";
	char mysql_pwd[256] = "zxcvfdsa321";
	char mysql_db[256] = "cloud_disk";
	
	//ret = get_mysql_info(mysql_user, mysql_pwd, mysql_db);
	//if (ret != 0){
	//	goto END;
	//}
	
	//获取用户信息
	char user[128];
	char pwd[128];

	ret = get_login_info(reg_buf, user, pwd);

	//printf("ret = %d, %s,%s\n",ret, user, pwd);

	
	if (0 != ret)
	{
		ret = -1;
		goto END;
	}
	
	//连接数据库
	conn = mysql_conn(mysql_user, mysql_pwd, mysql_db);
	if (NULL == conn)
	{
		ret = -1;
		goto END;
	}
	
	//设置数据库密码，注意处理中文编码问题
	mysql_query(conn, "set names utf8");
	
	char sql_cmd[SQL_MAX_LEN] = {0};
	
	sprintf(sql_cmd, "select password from user where name = '%s'", user);
	
	//查看用户是否存在
	int ret2 = 0;
	//返回值：-1失败，0成功
	ret2 = process_result_one(conn, sql_cmd, pwd);
	if (ret2 != 0) //密码不对或者用户名不对
	{
		ret = -1;
		goto END;
	}
	

END:
	
	if (conn != NULL)
	{
		mysql_close(conn); //断开数据库连接
	}
	
	return ret;
}



int main ()
{


    int count = 0;

    while (FCGI_Accept() >= 0) {
        char *contentLength = getenv("CONTENT_LENGTH");
        int len;

	printf("Content-type: text/html\r\n"
	    "\r\n"
	    );

        if (contentLength != NULL) {
            len = strtol(contentLength, NULL, 10);
        }
        else {
            len = 0;
        }

        if (len <= 0) {
	    printf("No data from standard input.<p>\n");
        }
        else {
			char buf[4*1024];
            int i, ch;
			int ret = 0;
			char * out;

	    //printf("Standard input:<br>\n<pre>\n");
            for (i = 0; i < len; i++) {
                if ((ch = getchar()) < 0) {
                    printf("Error: Not enough bytes received on standard input<p>\n");
                    break;
			}
                buf[i] = ch;
            }
			//printf("loginINFO: %s\n",buf);
			/*
			登陆：
				成功：{"code": "000"}
				失败：{"code": "001"}
			*/
			
			ret = user_login(buf);
			if (ret == 0)//登陆成功
			{
				//返回登陆情况，000代表成功
				out = return_status("000");
			}
			else if (ret == -1)
			{
				//返回当前注册情况，001代表失败
				out = return_status("001");
			}
			
			if (out != NULL)
			{
				printf(out); //给前端反馈信息
				free(out);
			}
            //printf("\n</pre><p>\n");
        }

    } /* while */

    return 0;

}

```

