---

title: Linux 进程管理
date: 2018-09-05 8:30:50
tags: Linux	
categories: "实验楼学习笔记之Linux"

---

介绍一些 Linux 所提供的工具来进行进程的查看与控制，掌握这些工具让我们能在某些进程出现异常的时候及时查看相关的指标，从而解决问题。<!--more-->

## 一、进程查看

- `top`:实时的查看进程的状态
- `ps`:静态查看当前的进程信息
- `pstree`:查看当前活跃进程的属性结构

### 1.1 top工具的使用

top工具是常用的一个查看工具，能实时的查看系统的一些关键信息：

	top

![](https://i.imgur.com/YwMabFK.png)

top是一个在前台执行的程序，所以执行后变进入到这样的一个交互界面，正因交互界面我们才可以实时的获取到系统于进程的信息，在交互界面我们eyi通过一些指令来操作和筛选，在此之前想了解显示的内容：

看到top显示的第一排：

| 内容 | 解释 |
|---|
| top | 表示当前的程序名称 |
| 09：12：35 | 表示当前的系统时间 |
| up 16 days, 1:09 | 表示当前机器已经启动了多长时间 |
| 1 user | 表示当前系统中只有一个用户|
| load average: 0.86,0.14,0.19 | 分别对应1，5，15分钟内cpu的评价负载 |

load average 在 wikipedia 中的解释是 the system load is a measure of the amount of work that a computer system is doing 也就是对当前 CPU 工作量的度量，具体来说也就是指运行队列的平均长度，也就是等待 CPU 的平均进程数相关的一个计算值。

我们该如何看待这个load average 数据呢？

假设我们的系统是单 CPU、单内核的，把它比喻成是一条单向的桥，把CPU任务比作汽车。

- load = 0 的时候意味着这个桥上并没有车，cpu 没有任何任务；
- load < 1 的时候意味着桥上的车并不多，一切都还是很流畅的，cpu 的任务并不多，资源还很充足；
- load = 1 的时候就意味着桥已经被车给沾满了，没有一点空隙，cpu 的已经在全力工作了，所有的资源都被用完了，当然还好，这还在能力范围之内，只是有点慢而已；
- load > 1 的时候就意味着不仅仅是桥上已经被车占满了，就连桥外都被占满了，cpu 已经在全力的工作了，系统资源的用完了，但是还是有大量的进程在请求，在等待。若是这个值大于２，大于３，超过 CPU 工作能力的 2，３。而若是这个值 > 5 说明系统已经在超负荷运作了

这是单个 CPU 单核的情况，而实际生活中我们需要将得到的这个值除以我们的核数来看。我们可以通过一下的命令来查看 CPU 的个数与核心数

	#查看物理cpu的个数
	cat /proc/cpuinfo | grep "physical id" | sort | uniq | wc -l
	#每个cpu的核心数
	cat /proc/cpuinfo | grep "physical id" | grep "0" | wc -l

![](https://i.imgur.com/xETapiv.png)


通过上面的指数我们可以得知 load 的临界值为 1 ，但是在实际生活中，比较有经验的运维或者系统管理员会将临界值定为0.7。这里的指数都是除以核心数以后的值，不要混淆了

- 若是 load < 0.7 并不会去关注他；
- 若是 0.7< load < 1 的时候我们就需要稍微关注一下了，虽然还可以应付但是这个值已经离临界不远了；
- 若是 load = 1 的时候我们就需要警惕了，因为这个时候已经没有更多的资源的了，已经在全力以赴了；
- 若是 load > 5 的时候系统已经快不行了，这个时候你需要加班解决问题了

通常我们都会先看 15 分钟的值来看这个大体的趋势，然后再看 5 分钟的值对比来看是否有下降的趋势。


top 的第二行数据，基本上第二行是进程的一个情况统计

| 内容	| 解释 | 
| --- | 
| Tasks: 28 total	|  进程总数 |  　
| 1 running	| 1个正在运行的进程数 | 
| 26 sleeping	| 25个睡眠的进程数 | 
| 1 stopped	　| 没有停止的进程数 | 
| 0 zombie	| 没有僵尸进程数 | 


top 的第三行数据，这一行基本上是 CPU 的一个使用情况的统计

| 内容	| 解释 |
| Cpu(s): 0.6us	| 用户空间进程占用CPU百分比（0.6%）| 
| 0.2 sy	| 内核空间运行占用CPU百分比（0.2%） |
| 0.0 ni	| 用户进程空间内改变过优先级的进程占用CPU百分比（0.0%） | 
| 98.6 id	| 空闲CPU百分比 |
| 0.6 wa	| 等待输入输出的CPU时间百分比 |
| 0.0 hi	| 硬中断(Hardware IRQ)占用CPU的百分比 | 
| 0.0 si	| 软中断(Software IRQ)占用CPU的百分比 | 
| 0.0 st	| (Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比 | 

CPU 利用率是对一个时间段内 CPU 使用状况的统计，通过这个指标可以看出在某一个时间段内 CPU 被占用的情况，而 Load Average 是 CPU 的 Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数情况统计信息，这两个指标并不一样。

top的第四行数据，这一行基本是内存的一个使用情况的统计

| 内容 | 解释 |
|---|
| 8175596 total | 物理内存总量 |
| 1677840 free | 空间的物理内存总量 |
| 1806640 used | 使用的物理内存总量 |
| 4691116 buff/cache | 用作内存缓存的内存量 |

>注意：系统中可用的物理内存最大值并不是 free 这个单一的值，而是 free + buffers + swap 中的 cached 的和

 top 的第五行数据，这一行基本上是交换区的一个使用情况的统计

| 内容 | 解释 |
|---|
| 0 total | 交换区总量 |
| 0 free | 空闲的交换区总量 |
| 0 used | 使用的交换区总量 |
| 60208884 avail Mem| 可用交换区总量 |

再下面就是进程的一个情况：

| 列名 | 解释 |
|---|
| PID	| 进程id | 
| USER	| 该进程的所属用户 | 
| PR	| 该进程执行的优先级 priority 值 | 
| NI	| 该进程的 nice 值 | 
| VIRT	| 该进程任务所使用的虚拟内存的总数 | 
| RES	| 该进程所使用的物理内存数，也称之为驻留内存数 | 
| SHR	| 该进程共享内存的大小 | 
| S	| 该进程进程的状态: S=sleep R=running Z=zombie |  
| %CPU	| 该进程CPU的利用率 | 
| %MEM	| 该进程内存的利用率 | 
| TIME+	| 该进程活跃的总时间 | 
| COMMAND	| 该进程运行的名字 |

> 注意

> NICE 值叫做静态优先级，是用户空间的一个优先级值，其取值范围是-20至19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低

> PR 值表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 MAX_PRIO，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 0-139，这个值越小，优先级越高。而这其中的 0 - 99 是实时进程的值，而 100 - 139 是给用户的。

> 其中 PR 中的 100 to 139 值部分有这么一个对应 PR = 20 + (-20 to +19)，这里的 -20 to +19 便是nice值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同

> ** VIRT **任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap空间的页面等所占据空间的总数 


top是一个前台程序，所以是一个可以交互的：

| 常用交互命令	| 解释| 
| ---| 
| q	| 退出程序| 
| I	| 切换显示平均负载和启动时间的信息| 
| P	| 根据CPU使用百分比大小进行排序| 
| M	| 根据驻留内存大小进行排序| 
| i	| 忽略闲置和僵死的进程，这是一个开关式命令| 
| k	| 终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。| 


### 1.2 ps工具的使用

ps也是常用查看进程的工具之一，罗列出所有信息如下：

	ps aux

![](https://i.imgur.com/qTY8rOh.png)

还可以在查看时，将连同部分的进程呈树状显示出来
	ps axjf

![](https://i.imgur.com/TiG1vzW.png)



| 内容 | 解释 |
|---|
| F	| 进程的标志（process flags），当 flags 值为 1 则表示此子程序只是 fork 但没有执行 exec，为 4 表示此程序使用超级管理员root权限 | 
| USER	| 进程的拥有用户| 
| PID	| 进程的 ID| 
| PPID	| 其父进程的 PID| 
| SID	| session 的 ID| 
| TPGID	| 前台进程组的 ID| 
| %CPU	| 进程占用的 CPU 百分比| 
| %MEM	| 占用内存的百分比| 
| NI	| 进程的 NICE 值| 
| VSZ	| 进程使用虚拟内存大小| 
| RSS	| 驻留内存中页的大小| 
| TTY	| 终端 ID| 
| S or STAT	| 进程状态| 
| WCHAN	| 正在等待的进程资源| 
| START 　| 	启动进程的时间| 
| TIME	| 进程消耗CPU的时间| 
| COMMAND	| 命令的名称和参数　| 

TPGID栏写着-1的都是没有控制终端的进程，也就是守护进程

STAT表示进程的状态，而进程的状态有很多，如下表所示

| 状态 | 解释 |
|---|
| R	| Running.运行中| 
| S	| Interruptible Sleep.等待调用| 
| D	| Uninterruptible Sleep.不可中断睡眠| 
| T	| Stoped.暂停或者跟踪状态| 
| X	| Dead.即将被撤销| 
| Z	| Zombie.僵尸进程| 
| W	| Paging.内存交换| 
| N	| 优先级低的进程| 
| <	| 优先级高的进程| 
| s	| 进程的领导者| 
| L	| 锁定状态| 
| l	| 多线程状态| 
| +	| 前台进程 |

使用 -l 参数可以显示自己这次登陆的 bash 相关的进程信息罗列出来

	ps -l


若是查找其中的某个进程的话，我们还可以配合着 grep 和正则表达式一起使用

	ps aux | grep zsh


当然如果觉得使用这样的此时没有把你想要的信息放在一起，我们也可以是用这样的命令，来自定义我们所需要的参数显示

	ps -afxo user,ppid,pid,pgid,command


### 1.3 pstree工具的使用

通过 pstree 可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程之间的相关性。

	pstree

![](https://i.imgur.com/ofoWvjb.png)


	pstree -up
	
	#参数选择：
	#-A  ：各程序树之间以 ASCII 字元來連接；
	#-p  ：同时列出每个 process 的 PID；
	#-u  ：同时列出每个 process 的所屬账户名称。


![](https://i.imgur.com/iaul5wL.png)


## 二、 进程管理

### 2.1 kill命令

当一个进程结束的时候或者要异常结束的时候，会向其父进程返回一个或者接收一个 SIGHUP 信号而做出的结束进程或者其他的操作，这个 SIGHUP 信号不仅可以由系统发送，我们可以使用 kill 来发送这个信号来操作进程的结束或者重启等等。


前面使用 kill 命令来管理一些 job，这里将尝试用 kill 来操作下一些不属于 job 范畴的进程


	#使用9这个信号强制结束 gedit 进程
	kill -9 1608


### 2.2 进程的控制顺序

在使用 ps 命令的时候可以看到大部分的进程都是处于休眠的状态，如果这些进程都被唤醒，那么该谁最先享受 CPU 的服务，后面的进程又该是一个什么样的顺序呢？进程调度的队列又该如何去排列呢？

当然就是靠该进程的优先级值来判定进程调度的优先级，而优先级的值就是上文所提到的 PR 与 nice 来控制与体现了

而 nice 的值我们是可以通过 nice 命令来修改的，而需要注意的是 nice 值可以调整的范围是 -20 ~ 19，其中 root 有着至高无上的权力，既可以调整自己的进程也可以调整其他用户的程序，并且是所有的值都可以用，而普通用户只可以调制属于自己的进程，并且其使用的范围只能是 0 ~ 19，因为系统为了避免一般用户抢占系统资源而设置的一个限制

	#打开一个程序放在后台，或者用图形界面打开
	nice -n -5 vim &
	
	#用 ps 查看其优先级
	ps -afxo user,ppid,pid,stat,pri,ni,time,command | grep vim

还可以用 renice 来修改已经存在的进程的优先级，同样因为权限的原因在实验环境中无法尝试

	renice -5 pid


![](https://i.imgur.com/iYxWfM0.png)