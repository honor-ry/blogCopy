---
title: 环境变量与文件查找
date: 2018-08-16 20:24:24
tags: 
	 - vim
	 - Linux
	 - 教程
categories: "实验楼学习笔记之Linux" #文章分類目錄 可以省略
---
介绍环境变量的作用与用法，及几种搜索文件的方法。学会这些技巧可以高效地使用 Linux 。<!--more-->
# 环境变量

## 变量

要解释环境变量，得先明白变量是什么，准确的说应该是 Shell 变量，所谓变量就是计算机中用于记录一个值（不一定是数值，也可以是字符或字符串）的符号，而这些符号将用于不同的运算处理中。通常变量与值是一对一的关系，可以通过表达式读取它的值并赋值给其它变量，也可以直接指定数值赋值给任意变量。为了便于运算和处理，大部分的编程语言会区分变量的类型，用于分别记录数值、字符或者字符串等等数据类型。Shell 中的变量也基本如此，有不同类型（但不用专门指定类型名），可以参与运算，有作用域限定。
```变量的作用域即变量的有效范围（比如一个函数中、一个源文件中或者全局范围），在该范围内只能有一个同名变量。一旦离开则该变量无效，如同不存在这个变量一般。```

shell创建变量

    declare tmp

shell变量复制

	temp=zxp

输出变量

	echo $temp

**注意**：并不是任何形式的变量名都是可用的，变量名只能是英文字母、数字或者下划线，且**不能以数字**作为开头

## 环境变量

环境变量的作用域比自定义变量的要大，如 Shell 的环境变量作用于自身和它的子进程。在所有的 UNIX 和类 UNIX 系统中，每个进程都有其各自的环境变量设置，且默认情况下，当一个进程被创建时，除了创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。Shell 程序也作为一个进程运行在操作系统之上，而我们在 Shell 中运行的大部分命令都将以 Shell 的子进程的方式运行。

通常我们会涉及到的变量类型有三种：

- 当前 Shell 进程私有用户自定义变量，如上面我们创建的 tmp 变量，只在当前 Shell 中有效。
- Shell 本身内建的变量。
- 从自定义变量导出的环境变量。
也有三个与上述三种环境变量相关的命令：set，env，export。这三个命令很相似，都是用于打印环境变量信息，区别在于涉及的变量范围不同。详见下表：

|命 令 |	说 明 |
|---|
|set | 显示当前 Shell 所有变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量。 |
| env | 显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。 |
| export | 显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。 |

### 环境变量永久生效

按变量的生存周期来划分，Linux 变量可分为两类：

- 永久的：需要修改配置文件，变量永久生效；

- 临时的：使用 export 命令行声明即可，变量在关闭 shell 时失效。

介绍两个重要文件 /etc/bashrc（有的 Linux 没有这个文件） 和 /etc/profile ，它们分别存放的是 shell 变量和环境变量。还有要注意区别的是每个用户目录下的一个隐藏文件： .profile 只对当前用户永久生效。而写在 /etc/profile 里面的是对所有用户永久生效，所以如果想要添加一个永久生效的环境变量，只需要打开 /etc/profile，在最后加上你想添加的环境变量就好啦。
查看每个用户的永久生效的环境变量：

    cd /home/用户名
    ls -a

## 命令查找路径与顺序

Shell 是怎么知道去哪找到这个命令然后执行的呢？这是通过环境变量 PATH 来进行搜索的，熟悉 Windows 的用户可能知道 Windows 中的也是有这么一个 PATH 环境变量。这个 PATH 里面就保存了 Shell 中执行的命令的搜索路径。

查看PATH环境变量路径：

    echo $PATH

其中给出的路径存放可执行文件，当在shell中执行命令时，系统就会安装PATH中设定的路径依次到目录中查找，如果找到同名文件，则执行先找到的文件。

### 创建Shell脚本
创建脚本文件，并打开
	gedit hello_world.sh

在打开的文本中输入：

    #！ /bin/bash   //该行不是注释，不能少
    for((i=0; i<10; i++));do
    	echo "hello world"
    done
    
    exit 0

为文件添加可执行权限

    chmod 755 hello_shell.sh

执行脚本

	./hello_shell.sh

## 创建C语言程序

创建并打开一个文件
	
	gidit hello_world.c

在文本中输入
	
	#include <stdio.h>
	
	int main(void)
	{
	 	printf("hello world");
		return 0;
	}

保存后，使用gcc生成可执行文件：
	
	gcc -o hello_world hello_world.c
*gcc生成二进制文件默认具有可执行文件，不需修改*

在/当前目录修创建一个目录`mybin`,并将上述文件移动到其中
	mkdir mybin
	mv hello_shell.sh hello_world mybin/

并进入`mybin`目录，运行上述两个程序：
	
	cd mybin
	./hello_shell.sh
	./hello_world

回到上一级目录，再运行程序，则发现提示命令找不到，除非加上命令的完整路径，但比较麻烦，可以进该路径添加到PATH环境变量。

## 添加自定义路径到“PATH”环境变量

	PATH=$PATH:/home/shiyanlou/mybin

**`=`之前之后不能添加空格，否则会提示变量不存在**</br>
注意：路径必须是绝对路径

这样在任意目录中，都可以执行上述两个文件，直接输入文件名即可执行。
到此，如果退出终端，再打开则会发现失效，可以添加一种自动执行的方式：
在每个用户的 home 目录中有一个 Shell 每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等等。zsh 的配置文件是 `.zshrc`，相应 Bash 的配置文件为` .bashrc `。它们在 `etc` 下还都有一个或多个全局的配置文件，不过我们一般只修改用户目录下的配置文件。

	echo "PATH=$PATH:/home/shiyanlou/mybin" >> .zshrc

上述命令中 >> 表示将标准输出以追加的方式重定向到一个文件中，注意前面用到的 > 是以覆盖的方式重定向到一个文件中，使用的时候一定要注意分辨。在指定文件不存在的情况下都会创建新的文件。

## 变量修改和删除
变量的修改有以下几种方式：

| 变量设置方式 | 说明 |
|---|
| ${变量名#匹配字串}	| 从头向后开始匹配，删除符合匹配字串的最短数据 |
| ${变量名##匹配字串}	| 从头向后开始匹配，删除符合匹配字串的最长数据 |
| ${变量名%匹配字串}	| 从尾向前开始匹配，删除符合匹配字串的最短数据 |
| ${变量名%%匹配字串}	| 从尾向前开始匹配，删除符合匹配字串的最长数据 |
| ${变量名/旧的字串/新的字串} | 将符合旧字串的第一个字串替换为新的字串 |
| ${变量名//旧的字串/新的字串} | 将符合旧字串的全部字串替换为新的字串 | 

## 变量删除

	unset temp

## 环境变量立即 生效
在 Shell 中修改了一个配置脚本文件之后（比如 zsh 的配置文件 home 目录下的 .zshrc），每次都要退出终端重新打开甚至重启主机之后其才能生效，很是麻烦，我们可以使用 source 命令来让其立即生效，如：

	source .zshrcc

`source `命令还有一个别名就是 `.`，注意与表示当前路径的那个点区分开，虽然形式不一样，但作用和使用方式一样，上面的命令如果替换成` . `的方式就该是:

	. ./.zshrc

注意第一个点之后必须有个空格，而且后面的文件必须指定完整的绝对或相对路径名，source 则不需要。

# 搜索文件

与搜索相关的命令常用的有 whereis，which，find 和 locate 。

## whereis简单快捷</br>
	whereis find
![](https://i.imgur.com/QHit5bQ.png)

找到了三个路径，两个可执行文件路径和一个 man 在线帮助文件所在路径，这个搜索很快，因为它并没有从硬盘中依次查找，而是直接从数据库中查询。whereis 只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。如果想要获得更全面的搜索结果可以使用 locate 命令。

## locate快而全

通过“ /var/lib/mlocate/mlocate.db ”数据库查找，不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 updatedb 命令更新一次，所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 updatedb 命令（在我们的环境中必须先执行一次该命令）。

	locate 文件名

安装软件包：`yum install mlocate`
##  which小而精
`which `本身是 `Shell` 内建的一个命令，通常使用 `which `来确定是否安装了某个指定的软件，因为它只从 PATH 环境变量指定的路径中去搜索命令：

	which man

## find精而细</br>

find 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。

	find / -name 文件名  //w文件名查找
	find /etc/ -name interfaces  //表示去 /etc/ 目录下面 ，搜索名字叫做 interfaces 的文件或者目录。

**
注意** find 命令的路径是作为第一个参数的， 基本命令格式为 `find [path] [option] [action]` 。

与时间相关的命令参数：

| 参数 | 说明 |
|---|
| -atime | 最后访问时间 |
| -ctime | 最后修改文件内容的时间 |
| -mtime | 最后修改文件属性的时间 |

下面以 -mtime 参数举例：

- `-mtime n：n` 为数字，表示为在 n 天之前的“一天之内”修改过的文件
- `-mtime +n`：列出在 n 天之前（不包含 n 天本身）被修改过的文件
- `-mtime -n`：列出在 n 天之内（包含 n 天本身）被修改过的文件
- `-newer file`：file 为一个已存在的文件，列出比 file 还要新的文件名</br>

	find ~ -mtime 0 //查找当天(24小时之内)右改动的文件
	find ~ -newer /home/shiyanlou/Code  //列出目录下比 Code 文件夹新的文件


以上内容来自:[实验楼](https://www.shiyanlou.com)