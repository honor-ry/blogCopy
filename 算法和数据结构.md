---
title: 算法和数据结构
date: 2019-10-12 11:44:14
tags: C++
mathjax: true
---

面试中常见的算法题目。

<!--more-->

#  实现Memmove

```C++
void * memmove(void *dest, void * src, size_t n){
    char * p1 = dest;
    char * p2 = src;
    whle(*p2 != '\0')
        *p1++ = *p2++;
    return p1;
}
```

## C语言的陷阱

- 内存重叠的处理
- 临时变量太多或者没有安全释放
- 没有测试内存越界
- 指针操作不熟悉

### 内存重叠

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190902142227.png)

对于内存重叠的情况，从尾到到头开始赋值。

## 正确写法

```C++
void * memmove(void *dest, const void * src, size_t n){
    char * p1 = dest;
    const char * p2 = src;
    if (p2 < p1){
        p2 += n;
        p2 += n;
        while(n-- != 0)
            *--p1 = *--p2;
    }else{
        while(n-- != 0)
            *p1++ = *p2++;
    }
    return p1;
}
```

# 面试考察的变成基本功

- 编程风格：缩进，括号，变量名
- 编程习惯：异常检查，边界处理
- 沟通：让面试官时刻明白你的意图
- 测试：主动写出合理的Testcase

## 代码风格

- 变量的命名：有意义的变量名，第一个单词的首字母小写，后面单词的首字母大写。
- 缩进：语句块
- 空格：运算符两边
- 代码可读性

类名大写。函数名首字母大写。变量名多个单词构成，第一个单词的首字母小写，后面单词的首字母大写。

一个函数只做一件事。

## 实战算法策略

- 总结归类相似题目
- 找出适合同一类题目的模板程序
- 对基础题数量掌握

## 排列组合模板

### 全排列

字符串”abc“的全排列。abc,acb,bac,....

无重复的全排序：

```C++
void Permutation(char * pstr, char * pBegin){
    if (!pStr && !pBegin)
		return;
    if (*pBegin == '\0')
        cout << *pStr << endl;
    else{
        for(char * pCh = pBegin; * pCh != '\0'; pCh++){
            swap(*pBegin, *pCh);
            Permutation(pStr, pBegin+1);
            swap(*pBegin, *pCh);
        }
    }
}
```

### 组合问题

题目：输入一个字符串，输出该字符串中字符的所有组合。举个例子，如果输入abc，它的组合有a、b、c、ab、ac、bc、abc。

对于每一个元素，可以有选或不选两个状态，因而从排列第一个元素开始，不选它然后求解S[2:n]的全自己；选它然后求解S[2:n]的全子集，两个结构的合并就是整个集合的全子集了。

# Array & String

## 入门题看String match

两种比较易于实现的字符串比较算法。

假设在长度为n的母串中匹配长度为m的子串。

#### 暴力求解

顺序遍历母串，将每个字符作为匹配的起始字符，判断是否匹配子串。时间复杂度为o(m×n)

```C++
//本人自己所写
char * strStr(const char * str, const char * target) {
	//边界条件考虑
	if (!*str || !*target)
		return nullptr;
	char * beginTarget = (char *)target;
	char * beginStr = (char *)str;
	while (*target != '\0') {
		if (*str == '\0')
			return nullptr;
		if (*target == *str) {
			target++;
			str++;
		}
		else {
			beginStr++;
			str = beginStr;
			target = beginTarget;
		}

	}
	return const_cast<char *>(str - strlen(beginTarget));
}
//视频中代码
char * strStr(const char * str, const char * target) {
	//边界条件考虑
	if (!*str || !*target)
		return nullptr;
	char * pStr = (char *)str;
	while (*pStr) {
		char * pBegin = pStr, *pTarget = (char*)target;
		while (*pStr && *pTarget && *pStr++ == *pTarget++) {}
		if (!*pTarget)
			return pBegin;
		pStr = pBegin + 1;
	}
	return nullptr;
}
```

#### Rabin-Karp

将每一个匹配子串映射为一个hash值。例如，将子串看做一个多进制数，比较它的值与母串中相同长度子串的hash值，如果相同，再细致地按字符确认字符串是否确实相同。顺序计算母串hash值的过程中，使用增量计算的方法：扩初最高位的hash值，增加最低位的hash值。因此能在平均情况下做到o(m+n)。

伪码：

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190903203101.png)

```c++
#include <iostream>
#include <string>
using namespace std;
//Mask 函数用来生成一个字符串的编码
int Mask(string str, const int n) {
	int mask = 1 << (str[0] - 'a');
	for (int i = 1; i < n; i++) {
		mask |= 1 << (str[i] - 'a');;
	}
	return mask;
}
int strStr(string str,string target) {
	int lenOfTarget = target.length();
	int lenOfStr = str.length();
	int maskTarget = Mask(target, lenOfTarget);
	int maskStr = Mask(str, lenOfTarget);
	for (int i = 0; i < lenOfStr - lenOfTarget + 1; i++) {
		if (maskStr == maskTarget) {
			if (str.substr(i, lenOfTarget) == target) //substr()获取string的一个子串，第一个参数是起始位置，第二个参数是子串长度
				return i;
		}
		maskStr = Mask(str.substr(i+1,i+lenOfTarget), lenOfTarget);
	}
}

int main()
{
	using namespace std;
	string str = "abdcabcda";
	string str2 = "abc";
	int c = strStr(str, str2);
	if (c)
		cout << c << endl;
    std::cout << "Hello World!\n"; 
}

```

还有一种方法实现就是KMP，比较复杂。

## Array

```c++
int array[arraySize]; //在Stack上定义一个长度为arraySize的整型数组
int * array = new int[arraySize]; //在Heap上定义长度为arraySize的整型数组
//使用完后需要释放内存
delete [] array;
```

Stack主要是由操作系统自动管理的内存空间。但进入一个函数，操作系统会为该函数中的局部遍历分配存储空间。事实上，系统会分配一个内存块，叠加在当前的stack上，并且利用指针指向前一个内存块的地址。

函数的局部变量就存储在当前的内存块上。当该函数返回时，系统“弹出”内存块，并且根据指针回到前一个内存块。所以Stack总是以先进先出的方式工作。

Heap是用来存储动态分配变量的空间。对于Heap而言，并没有像stack那样后进先出的规则，程序员可以选择随时分配或回收内存。这就意味着程序员要自己用命令回收内存，否则会产生内存泄漏。

### 二维数组

在stack上创建：

```C++
int array[M][N];
void func(int arr[M][N]){} //M可以省略，但是N必须存在
```

在Heap上创建：

```C++
int **array = new int*[M];
//C语言
int array =  (int**)malloc(M * sizeof(int*));
for (int i = 0; i < M; i++)
    array[i] =  new int[N]; 
	//C语言
	array[i] =  (int*)malloc(N * sizeof(int));
void func(int **arr, int M, int N){}
for (int i = 0; i < M; i++)
    delete[] array[i];
delete[] array;
```

array不适合增减元素的场景。

### vector

vector可以用[]直接访问元素。

```C++
for (vector<int>::iterator it = v.begin(); it != v.end();){
    if (condition)
        it =v. erase(it); //返回删除it后的下一个有效元素
    else
        it++;
}

```

### Hash Table

Hash table几乎是最为重要的数据结构，主要用于基于“key”的查找，存储的元素基本元素是key-value的pair。逻辑上，数组可以作为Hash Table的一个特例：key是一个非负整数。

插入、删除和查找的时间复杂度都是o(1)。

#### 碰撞

- 开址法

- 拉链法

Java中的数据结构：

- Hash Table：同步的
- HashSet：在HashMap上省掉了value的值
- HashMap：不同步的，对于非线程效率更高的

C++中：

提供了map容器，可以插入、删除，查找；底层以红黑树实现的。

在C++11中，标准库中天骄了unordered_map使用Hash Table实现的。

## string

在C语言中，字符串指的是一个以‘\0’结尾的char数组。关于字符串的函数通常需要传入一个字符型指针。常用函数：

- strcpy

- strcat

- strstr

- strcmp

- strlen

- atoi

C++中string就是一个类，类中重载了+，<,>,=,==等操作符。常用函数：

- find
- substr
- erase
- length

## 字符串中字符是否唯一

判断一个字符串在字符串中是否只出现过一次。

```C++
#include <bitset>
bool isUnique(string str) {
	bitset<256> hashMap; //长度256，bitset用来存储0或1，true或false
	for (int i = 0; i < str.length(); ++i) {
		if (hashMap[(int)str[i]]) {
			return false;
		}
		hashMap[(int)str[i]] = 1;
	}
	return true;
}
```

## 两个字符串的是否为排列

无论如何变化，每个字符出现的次数一定相同。一旦需要统计一个元素集中元素出现的次数，就应该考虑使用hash table。

```C++
#include <unordered_map>
using namespace std;
bool isPermutation(string str1, string str2) {
	if (str1.length() != str2.length())
		return false;

	unordered_map<char, int> hashMapStr1;
	unordered_map<char, int> hashMapStr2;
	for (int i = 0; i < str1.length(); ++i) {
		hashMapStr1[str1[i]]++;
	}
	for (int i = 0; i < str2.length(); ++i) {
		hashMapStr2[str2[i]]++;
	}
	if (hashMapStr1.size() != hashMapStr2.size())
		return false;
	for (auto ite = hashMapStr1.begin(); ite != hashMapStr1.end(); ++ite) {
		if (ite->second != hashMapStr2[ite->first])
			return false;
	}
	return true;
}
```

## 字符串包含

给定一个newspaper和message两个字符串，检查是否message可以由newspaper中的字母所组成。

```C++
#include <unordered_map>
using namespace std;
bool canCompose(string newspaper, string message) {
	if (message.size() == 0)
		return true;
	if (newspaper.size() == 0)
		return false;
	unordered_map<char, int> hashMap;
	for (int i = 0; i < newspaper.size(); ++i) {
		hashMap[newspaper[i]]++;
	}
	for (int i = 0; i < message.size(); ++i) {
		hashMap[message[i]]--;
		if (hashMap[message[i]] < 0)
			return false;
	}
	return true;
}
```

## anagram(字谜)

决定两个字符串是否是字谜。

比如：s='abcd', t='dcab' , return true

要求，时间复杂度o(n)，空间复杂度o(1)

```C++
#include <algorithm>
#include <string>
using namespace std;
bool Anagram(string s, string t) {
	if (s.size() != t.size())
		return false;
	if (s.size() == 0)
		return true;
	sort(s.begin(), s.end());
	sort(t.begin(), t.end());
	for (int i = 0; i < s.size(); i++) {
		if (s[i] != t[i])
			return false;
	}
	return true;
}
```



## 两数之和在数组中

判断两个数的和是否存在数组之中。

```C++
#include <iostream>
#include <map>
using namespace std;
vector<int> addsToTarget(vector<int> &numbers, int target) {
	map<int, int> hashMap;
	vector<int> res;
	for (int i = 0; i < numbers.size(); ++i) {
		if (hashMap.count(target - numbers[i])) {
			res.push_back(hashMap[target-numbers[i]]);
			res.push_back(i);
			return res;
		}
		hashMap[numbers[i]] = i;
	}
}
```

## 数组中连续序列

求出数组中最长连续序列的长度。例如，给定数组[31,6,32,1,3,2]，最长连续序列为[1,2,3]。返回它的长度3。

```C++
struct Bound {
	int low;
	int high;
	Bound(int l = 0, int h = 0):low(l), high(h){}
};
int longestConsecutive(vector<int> &num) {
	unordered_map<int, Bound> table;

	int local = 0;
	int maxLen = 0;
	for (int i = 0; i < num.size(); ++i) {
		if (table.count(num[i]))//跳过重复元素
			continue;
		local = num[i];

		int low = local, high = local;
        //判断小1或大1的元素是否在table中
		if (table.count(local - 1))  
			low = table[local - 1].low;
		if (table.count(local + 1))
			high = table[local + 1].high;

		table[low].high = table[local].high = high;
		table[high].low = table[local].low = low;

		if (high -  low + 1 > maxLen)
			maxLen = high - low + 1;
	}
	return maxLen;
}
```

## Longest Common SubString最长相同子字符串

例如：

str1="ABCD", str2="CBCE"，return 2.

```C++
int longestCommonSubString(string &A, string &B) {
	if (A.empty() || B.empty())
		return 0;

	int lcs = 0, lcs_temp = 0;
	for (int i = 0; i < A.size(); ++i)
		for (int j = 0; j < B.size(); j++) {
			lcs_temp = 0;
			while (i + lcs_temp < A.size() && j + lcs_temp < B.size() 
                   && A[i + lcs_temp] == B[j + lcs_temp])
				++lcs_temp;
			if (lcs < lcs_temp)
				lcs = lcs_temp;
		}
	return lcs;
}
```

# 链表

- 反转链表
- 链表的倒数第k个节点
- 深度拷贝链表（链表节点有随机指针）
- 链表有环判断，入口节点
- 链表的顺序遍历和逆序遍历相同
- 合并两个有序链表，合并K个有序 链表

# 栈和队列

```c++
stack<int> myStack;
myStack.push(10);
myStack.push(20);
int value = myStack.top();
myStack.pop();

queue<int> myQueue;
myQueue.push(10);
myQueue.push(20);
int value = myQueue.front();
myQueue.pop();
```

栈经常用于实现深度优先算法(DFS)。

队列经常用于实现广度优先算法(BFS)。

堆：

- 通过stack实现特殊顺序的读取：通常需要两个stack
- 通过栈实现队列 
- 对栈进行排序，借用一个栈使用
- 有效的括号， 比如“([])”, "[(}]"
- 解决Top-Down结构的问题，比如：二叉树的周游问题，二叉树的中序遍历
- 后缀表达式计算

队列：

- 循环队列
- 优先队列

# 二叉树

- 完全二叉树：只有最下面两层节点的度数可以小于2，并且最下面的节点集中在该层最左侧

- 满二叉树：二叉树的任意节点要么是叶子节点，要么是度为2的节点，不存在度为1的节点。

二叉树的遍历：

- 前序遍历：根->左节点->右节点
- 中序遍历：左节点->根->右节点
- 后序遍历：左节点->叶节点->根

三种遍历方式都是深度优先算法，优先考虑递归实现，也可以使用栈数据结构实现。

广度优先遍历：首先访问第一层，然后第二层，依此类推

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190923084839.png)

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190923084910.png)

![1569199954806](C:\Users\zxp\AppData\Roaming\Typora\typora-user-images\1569199954806.png)

## 分治算法

步骤：分解，解决，合并

- 二分搜索
- 大整数乘法
- 归并排序
- 快速排序

## 二分查找树

对于二分查找树的任意节点，该节点存储的数值一定比左子树的所有节点的值大，比右子树的所有节点的值小。

中序遍历二分查找树得到一个升序的序列。

由于二叉树第L层至多可以存储2^L个节点，故树的高度应该在logn量级，因此，二叉搜索树的搜索效率为o(longn)。

如果退化为一个右小到大的单链表（每个节点只有右孩子），其搜索效率变为o(n)。

判断一棵树是否为二叉搜索树：

- 第一种方法：通过中序遍历得到序列，然后判断是否为升序的
- 第二种方法：同时传入最小/最大值，并且见初始值设为INT_MAX，INT_MAX，这样左子树所有节点的值必须在INT_MIN及根节点的值之间，其右子树所有节点的值必须在根节点的值以及INT_MAX之间。

```c++
bool helper(TreeNode* root, int min, int max)
{
    if(nullptr == root)
        return true;
    if((root->val < max || (root->val == max && root->right == nullptr)) &&
       (root->val > min || (root->val == min && root->left == nullptr)))
    {
        return helper(root->left, min, root->val) &&
            helper(root->right, root->val, max);
    }
    return false;
}

bool isValidBST(TreeNode* root)
{
    return helper(root, INT_MIN, INT_MAX);
}
```



## 平衡二叉树

一棵树为平衡二叉树，当且仅当左右两个子树的高度差的绝对值不超过1，并且左右两个子树也是一颗平衡二叉树。

空树是一个平衡二叉树。

判断一棵树是否为平衡二叉树：

```c++
int level(TreeNode* root)
{
    if(!root)
        return 0;
    return max(level(root->left),level(root->right))+1;
}

bool isBalanced(TreeNode* root)
{
    if (!root)
        return true;
    int factor = abs(level(root->left) - level(root->right));
    return factor > 2 ? false : isBalenced(root->left)&&isBalance(root->rihgt);
}
```

上述方法中，level要多次重复计算。

可以采用动态规划来避免level的多次计算。

```c++
int isBalancedHelper(TreeNode* root)
{
    if(nullptr == root)
        return 0;
    int leftHeight = isBalancedHelper(root->left);
    if (leftHeight == -1)
        return -1;
    
    int rightHeight = isBalancedHelper(root->right);
    if(rightHeight == -1)
        return -1;
    
    if (abs(leftHeight - rightHeight) > 1)
        return -1;
    
    return max(leftHeight, rightHeight) + 1;S
}

bool isBalanced(TreeNode* root)
{
    return isBalancedHelper(root) != -1;
}
```

## 求二叉树中路径

求取二叉树的所有路径中，和等于某个值的路径。

```c++
void pathSumHelper(vector<int> path, vector<vector<int> >& result, TreeNode* root, int sum)
{
    if(nullptr == root)
        return ;
    path.push_back(root->val);
    if(sum == root->val)
        result.push_back(path);
    pathSumHelper(path, result, root->left, sum - root->val);
    pathSumHelper(path, result, root->right, sum - root->val);
}

vector<vector<int> > pathSum(TreeNode* root, int sum)
{
    vector<int> path;
    vector<vector<int> > result;
    pathSumHelper(path, result, root, sum);
    return result;
}
```

如果要求路径的尾部一定是叶子节点：

```c++
void pathSumHelper(vector<int> path, vector<vector<int> >& result, TreeNode* root, int sum)
{
    if(nullptr == root)
        return ;
    path.push_back(root->val);
    if(sum == root->val && nullptr == root->right && nullptr == root->left);
        result.push_back(path);
    pathSumHelper(path, result, root->left, sum - root->val);
    pathSumHelper(path, result, root->right, sum - root->val);
}

vector<vector<int> > pathSum(TreeNode* root, int sum)
{
    vector<int> path;
    vector<vector<int> > result;
    pathSumHelper(path, result, root, sum);
    return result;
}
```

## 二叉搜索树的中序遍历的下一个元素

```c++
TreeNode* leftMostNode(TreeNode* node)
{
    if(!node)
        return nullptr;
    while(nullptr != node->left)
        node = node->left;
    return node;
}
bool isLeftChild(TreeNode* node, TreeNode* parent)
{
    return parent->left == node;
}
TreeNode* inOrderSuccessor(TreeNode* node)
{
    if(nullptr == node)
        return nullptr;
    if(nullptr != node->right)
        return leftMostNode(node->right);
    TreeNode* parent = node->parent;
    while(parent && !isLeftChild(node, parent))
    {
        node = parent;
        parent = node->parent;
    }
    return parent;
}

```

如果节点没有父指针。

```c++
TreeNode* leftMostNode(TreeNode* node)
{
    if(!node)
        return nullptr;
    while(nullptr != node->left)
        node = node->left;
    return node;
}
TreeNode* inOrderSuccessor(TreeNode* node, TreeNode* root)
{
    if(!node)
        return nullptr;
    if(!node->right)
        return leftMostNode(node->right);
    TreeNode* successor = nullptr;
    while(root)
    {
        if(root->val > node->val)
        {
            successor = root;
            root = root->left;
        }
        else
            root = root->right;
    }
    return successor;
}
```

## 最近的公共节点

![1569322792414](C:\Users\zxp\AppData\Roaming\Typora\typora-user-images\1569322792414.png)



```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* A, TreeNode* B)
{
    if(nullptr == root || root == A || root == B)
        return root;
    TreeNode* left = lowestCommonAncestor(root->left, A, B);
    TreeNode* right = lowestCommonAncestor(root->right, A, B);
    
    if(nullptr != left && nullptr != right)
        return root;
    
    return (nullptr != left) ? left : right;
}
```

## 重构二叉树

根据两个遍历序列来重构二叉树。

比如：根据先序遍历和中序遍历。

```c++
TreeNode* rebuild(char * pStr, char *iStr, int n)
{
	if(n <= 0)   
        return nullptr;
    TreeNode* root = new TreeNode;
    root->data = *pStr;
    
    char * iter;
    for(iter = iStr; iter < iStr+n; ++iter)
    {
        if(*iter== *pStr)
            break;
    }
    
    int k = iter - iStr;
    root->left = rebuild(pStr+1, iStr, k);
    root->right = rebuild(pStr+k+1, iter+k, n-k-1);
    
    return root;
}
```

## 之字形打印二叉树

```c++
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
class Solution {
public:
    vector<vector<int> > Print(TreeNode* pRoot) {
        vector<vector<int> > result;
        stack<TreeNode*> sta1;
        stack<TreeNode*> sta2;
        int level = 1;
        if(pRoot)
        {
            sta1.push(pRoot);
        }
        while(!sta1.empty() || !sta2.empty())
        {
            vector<int> line;
            int n = sta1.empty() ? sta2.size() : sta1.size();
            while(n--)
            {
                if (level % 2 == 1)
                {
                    TreeNode * temp = sta1.top();
                    sta1.pop();
                    line.push_back(temp->val);
                    if(temp->left)
                        sta2.push(temp->left);
                    if(temp->right)
                        sta2.push(temp->right);
                }
                else{
                    TreeNode * temp = sta2.top();
                    sta2.pop();
                    line.push_back(temp->val);
                    if(temp->right)
                        sta1.push(temp->right);
                    if(temp->left)
                        sta1.push(temp->left);
                }
            }
            ++level;
            result.push_back(line);
        }
        return result;
    }
    
};
```

# 排序

## 内排序

内排序是指所有的数据已经读入内存，在内存中进行排序的算法。排序过程中不需要对磁盘进行读写。同时，内排序一般假定所有用到的辅助空间也可以直接存在于内存中。

另一类排序称作外排序，即存在中无法保存全部数据，需要进行磁盘访问，每次读入部分数据到内存进行排序。

- 快速排序
- 归并排序
- 堆排序
- 桶排序和基数排序

### 归并排序

将线性数据结构（如array，vector或list）分为两部分，对两部分分别进行排序，排序完成后，再将各自排序好的两个部分合并还原成一个有序数组。

由于归并排序不依赖于随机读写，因此具有很强的普适性，适用于list等数据结构。算法的时间复杂度O(nlongn)，需要额外O(n)空间。

```c++
void merge_sort(int array[], int helper[], int left, int right)
{
    if (left >= right)
        return;
    int mid = right - (right - left)/2;
    merge_sort(array, helper, left, mid);
    merge_sort(array, helper, mid+1, right);
    
    int helperLeft = left;
    int helperRight = mid + 1;
    int cur = left;
    while(helperLeft <= mid && helperRight <= right)
    {
        if(helper[helperLeft] > helper[helperRight])
            array[curr++] = helper[helperRight++];
        else
            array[curr++] = helper[helperLeft++];
    }
    
    while(helperLeft <= mid)
        array[curr++] = helper[helperLeft++];
}
```

### 快速排序

快速排序是最为常用的排序算法，算法核心于归并排序类似，也采用“分而治之”的想法。

随机选定一个元素作为轴值，利用该轴值将数组分为左右两部分，左边的元素都比轴值小，右边元素都比轴值大，但他们不是安全排序的。在此基础上，分别对左右两部分分别递归调用快速排序，使得左右部分完全排序。

算法的平均时间复杂度是O(nlogn)，在最坏的情况为O(n^2)，额外空间复杂度O(longn)。

```c++
int partition(int array[], int left, int right)
{
    int pivot = array[right];
    while(left != right)
    {
        while(left < right && array[left] < pivot)
            left++;
        if(left < right)
            swap(array[left], array[right--]);
        while(left < right && array[right] > pivot)
            right--;
        if(left < right)
            swap(array[left++], array[right]);
    }
    array[left] = pivot;
    return left;
}
void qSort(int array[], int left, int right)
{
    if (left >= right)
    	return;
    int index = partition(array, left, right);
    qSort(array, left, index-1);
    qSort(array, index+1, right);
}
void qSort(int array[], int size)
{
    qSort(array, 0, size-1);
}
```

### 快速选择排序

快速选择算法能够在平均O(n)时间内从**一个无序数组中返回第K大的元素。**

算法实际上利用了快速排序的思想，将数组依照一个轴值分割成两个部分，左边元素都比轴值小，右边元素都比轴值大。

```c++
int partition(int array[], int left, int right)
{
    int pivot = array[right];
    while(left != right)
    {
        while(left < right && array[left] < pivot)
            left++;
        if(left < right)
            swap(array[left], array[right--]);
        while(left < right && array[right] > pivot)
            right--;
        if(left < right)
            swap(array[left++], array[right]);
    }
    array[left] = pivot;
    return left;
}
int quik_select(int array[], int left, int right, int k)
{
    if (left >= right)
        return array[left];
    int index = partition(array, left, right);
    int size = index - left + 1;
    if(size == k)
        return array[left+k-1];
    else(size > k)
        return quik_select(array, left, index-1, k);
    else
        return quik_select(array, index+1, right, k-size);
}
```

### 桶排序

桶排序不需要进行数据之间的两两比较，但是需要事先直到数组的一些具体情况。

特别地，桶排序适用于知道待排序数组大小范围的情况。其特性在于将数据根据其大小，放入合适的“桶（容器）”中，再依次从桶中取出，形成有序序列。

时间复杂度：O(max+n), 空间复杂度O(n+max)

```c++
void BucketSort(int array[], int n, int max) //max为array中数的最大值
{
    int tempArray[n];
    int i;
    for (i = 0; i < n; ++i)
        tempArray[i] = array[i];
    
    int count[max]; //桶
    memset(count, 0, max * sizeof(int));
    
    for(i = 0; i < n; ++i)
        count[array[i]]++;
    for(i = 1; i < max; i++)
        count[i] = count[i-1]+count[i];
    
    for(i = 0; i < n; ++i)
        array[--count[tempArray[i]]] = tempArray[i];
    
}
```

### 基数排序

```c++
void RadixSort(int Array[], int n, int digits, int radix)
{
    int *TempArray = new int[n];
    int * count = new int[radix];
    int i, j, k;
    int Radix = 1;
    
    for(i = 1; i <= digits; i++)
    {
        for (j = 0; j < radix; j++)
            count[j] = 0;
        for (j = 0; j < n; j++)
        {
            k = (Array[j] / Radix) % radix;
            count[k]++;
        }
        
        for(j = 1; j < radix; j++)
            count[i] = count[i-1] + count[i];
        
        for (j = n - 1; j >= 0; j--)
        {
            k = (Array[j] / Radix) % radix;
            count[k]--;
            TempArray[count[k]] = Array[j];
        }
        for (j = 0; j < n; ++j)
            Array[j] = TempArray[j];
        Radix *= radix;
    }
    delete [] TempArray;
    delete [] count;
}
```



## 外排序

假设文件需要分成k块读入，需要从小到达进行排序：

- 依次读入每个文件快，在内存中对当前文件块进行排序（应用恰当的内排序算法）。此时，每块文件相等于一个由小到大排列的有序队列。
- 在内存中建立一个最小值堆，读入每块文件的队列头
- 弹出堆顶元素，如果元素来自第i块，则从第i块文件中补充一个元素到最小值堆。弹出的元素暂存至临时数组
- 当临时数组存满，将数组写至磁盘，并清空数组内容。
- 重复第3、4步，直到所有文件块读取完毕。

## 堆和堆排序

根节点元素比它的所有子节点都要大。

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190925144546.png)

- 堆能够很方便地维护动态数据的最大值、最小值或中位数(需要两个堆)。
- 优先队列相比简单的queue更适用于需要优先级的情景
- 与queue类似，该结构适合push和pop，但不方便update和检索。

### 堆实现

堆的底部实现是一个动态数组。

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190925144947.png)

### 堆排序

堆排序利用了堆作为逻辑存储结果，将输入array变成一个最大值堆，然后，我们反复进行堆的弹出操作。

时间复杂度O(nlogn)

```c++
void downHeap(int a[], int N, int k)
{
    int j, v;
    v = a[k];
    while (k <= N/2)
    {
        j = K + k;
        if (j < k && a[j] < a[j+1]) j++;
        if (v >= a[j]) break;
        a[k] = a[j]; 
        k = j;
    }
    a[k] = v;
}

void heapSort(int a[], int N)
{
    int k , t;
    for (k = N/2; k>=1; --k)
        downHeap(a, N, k);
    while(N > 1)
    {
        t = a[1];
        a[1] = a[N];
        a[N] = t;
        downHeap(a, --N, 1);
    }
}
```

### c++中堆和优先级队列

```c++
priority_queue<int> myPriorityQueue;
myPriorityQueue.push(30);
myPriorityQueue.push(20);
myPriorityQueue.push(50);
myPriorityQueue.push(40);

while(!myPriorityQueue.empty())
{
    cout << ' ' << myPriorityQueue.top();
    myPriorityQueue.pop();
}

//输出： 50 40 30 20
```

当题目中出现“前k个”，“合并/排序k组数据”或者“数据流（即不知道全部数据，而是每次读入一个）”时，可以考虑使用heap，动态地维护最大值/最小值信息。 

# 二分搜索

递归实现：

```c++
int binarySearch(int* array, int left, int right, int value)
{
    if(left > right)
        return -1;
    int mid = left + (right - left) / 2;
    if (array[mid] == value)
        return mid;
    else if(array[mid] > value)
        return binarySearch(array, left, mid-1, value);
    else
        return binarySearch(array, mid+1, right, value);
}
```

循环实现：

```c++
int binarySearch(const int* array, const int size, const int val)
{
    int left = 0;
    int right = size-1;
    while(left <= right)
    {
        int mid = left + (right - left) >> 1;
        if (val == array[mid])
            return mid;
        else if(array[mid] > val)
            right = mid - 1;
        else
            left = mid + 1;   
    }
    return -1;
}
```

对于**有序或者部分有序容器**的搜索：二分查找或其变种基本上都是最佳的方法。

## 数组中下标等于对应元素值

从一个有序数组中，找到其值等于下标值的元素：

```c++
int findValueEqualIndex(int* array, int size)
{
    int left = 0;
    int right = size - 1;
    while(left <= right)
    {
        int mid = left + (right - left) >> 2;
        if (mid == array[mid])
            return mid;
        else if(mid < array[mide])
            right = mid - 1;
        else
            left = mid + 1;
    }
    return -1;
}
```

## 寻找峰值

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190925184730.png)

```c++
//[1,2,1,3,4,5,7,6]  //峰值有2，7
int findPeakHelper(const int* array, int left, int right, int n)
{
    int mid = left + (right - left)/2;
    if ((mid == 0 || array[mid-1] <= array[mid]) &&
       (mid == n-1 || array[mide+1] <= array[mid]))
        return mid;
    else if (mid > 0 && array[mid-1] > array[mid])
        return findPeakHelper(array, left, mid-1, n);
    else
        return findPeakHelper(array, mid+1, right, n);
} 
int findPeak(const int * array, int size)
{
    return findPeakHelper(array, 0, size-1);
}
```

## 旋转有序数组中查找

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190925193310.png)

```c++
int findElementInArrayHelper(int* array, int low, int high int target)
{
    if(left > right)
        return -1;
    int mid = low + (higt - low) / 2;
   	if (array[mid] == target)
        return mid;
    if (array[low] <= array[mid])
    {
        if (target >= array[low] && target <= array[mid])
            return findElementInArrayHelper(array, low, mid-1, target);
        else
            return findElementInArrayHelper(array, mid+1, high, target);
    }
    else
    {
        if (target >= array[mid] && target <= array[higt])
            return findElementInArrayHelper(array, mid+1, high, target);
        else
            return findElementInArrayHelper(array, low, mid-1, target);
    }
}

int findElementInArray(int * array, int size, int target)
{
    return findElementInArrayHelper(array, 0, size-1, target);
}
```

循环实现：

```c++
int findElementInArray(int * array, int size, int target)
{
    int low = 0;
    int high = size - 1;
    while(low <= high)
    {
        int mid = low + (high - low) >> 1;
        if (target == array[mid])
            return mid;
        if(array[low] <= array[mid])
        {
            if(array[low] <= target && target <= array[mid])
                high = mid - 1;
            else
                low = mid + 1;
        }
        else
        {
            if(array[mid] <= target && target <= array[higt])
                low = mid + 1;
            else
                high = mid - 1;
        }
    }
    return -1;
}
```

## 范围搜索

对于排序好的数组中，存在重复元素。找出某个元素的起始位置和结束位置。

```c++
void searchRangeHelper(int A[], int left, int right, int target, int begin, int end)
{
    if (left > right)
        return;
    int mid = left + (right - left) >> 1;
    if(A[mid] == target)
    {
        if (mid < begin || begin == -1)
            begin = mid;
        if (mid > end || end == -1)
            end = mid
        searchRangeHelper(A, left, mid-1, target, begin, end);
        searchRangeHleper(A, mid+1, right, target, begin, end);
    }
    else if (A[mid] < target)
        searchRangeHelper(A, mid + 1, right, target, begin, end);
    else
        searchRangeHelper(A, left, mid - 1, target, begin, end);
        
}
vector<int> searchRange(int A[], int n, int target)
{
    int begin = -1, end = -1;
    searchRangeHelper(A, 0, n-1,target, begin, end);
    
    vector<int> res;
    res.push_back(begin);
    res.push_back(end);
}
```

## 矩阵查找

一个M×N的矩阵，每一行、每一列都是排序的。

判断一个元素是否在该矩阵中。

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190925200822.png)

```c++
void searchMatrixHelper(vector<vector<int> > Matrix, int target, vector<int>& res)
{
    int row = Matrix.size();
    if (row == 0)
        return ;
    int column = Matrix[0].size();
    int j = column - 1;
    int i = 0; 
    vector<int> res;
    while(i < row && j >= 0)
    {
        if (Matrix[i][j] == target)
        {
            res.push_back(i);
            res.push_back(j);
            return res;
        }
        else if (Matrix[i][j] > target)
            --j;
        else
            i++;
    }
    return;
}
vector<int> searchMatrix(vector<vector<int> > Matrix, int target) 
{
    vector<int> res;
    searchMatrixHelper(Matrix, target, res);
    return res;
}
```

## 搜索矩阵

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190925202734.png)

首先通过判断最后一列，来判断元素在哪一行，然后在对应进行二分查找。

```c++
bool binarySearch(vector<int> array, const int val)
{
    int left = 0;
    int right = array.size()-1;
    while(left <= right)
    {
        int mid = left + (right - left) >> 1;
        if (val == array[mid])
            return true;
        else if(array[mid] > val)
            right = mid - 1;
        else
            left = mid + 1;   
    }
    return false;
}
bool searchMatrix(vector<vector<int> > Matrix, int target) 
{
    int row = Matrix.size();
    if (row <= 0)
        return false;
    int column = Matrix[0].size();
    int i = 0, j = column-1;
    while(i < n && j >= 0)
    {
        if (Matrix[i][j] == target)
            return true;
        if (Matrix[i][j] < target)
            i++;
        else
        {
            return binarySearch(Matirx[i], target);
        }
    }
    return false;
}
```

另一种思路就是将整个二维数组看作是一个一维数组。

```c++
bool searchMatrix(vector<vector<int> > Matrix, int target) 
{
    int row = Matrix.size();
    if (row <= 0)
        return false;
    int column = Matrix[0].size();
    int right = row * column-1;
 	int left = 0;
    while(left <= right)
    {
        int mid = left + (right - left) >> 1;
        if (Matrix[mid/column][mid%column] == target)
            return true;
        else if (Matrix[mid/column][mid%column] < target)
            right = mid + 1;
        else
        	left = mid - 1;
    }
    return false;
}
```

## 求平方根

即实现sqrt(x)，注意是整数，还是浮点数

```c++
const double precision = 0.00001;
double mySqrtHelper(double x, double lowBound, double highBound)
{
    double sqrt = lowBound / 2 + highBound /2 ;
    if (abs(sqrt * sqrt - x) < precision)
        return sqrt;
    else if(sqrt * sqrt - x > 0)
        return mySqrtHelper(x, lowBound, sqrt);
    else
        return mySqrtHelper(x, sqrt, highBound);
}

double mySqrt(double x)
{
    if(x < 0)
        return -1;
    if (x == 0)
        return 0;
    if (x == 1)
        return 1;
    if (x < 1)
        return mySqrtHelper(x, x, 1);
    else
    	return mySqrtHelper(x, 1, x);
}
```

牛顿迭代法，迭代的速度更快。

```c++
float sqareRoot(float n)
{
    float x = n;
    float y = 1;
    float e = 0.000001;
    while (x - y > e){
        x = (x + y)/2;
        y = n/x;
    }
    return x;
}
```

## 最新的请求

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190927202113.png)

## 人的年龄排序

对于人的数量比较大时，根据人的年龄排序，利用桶排序的效率比较高。

# 大规模和内存有限的问题

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190927203057.png)

## 社交网络

针对一个非常大的社交网络，设计一个数据结构和一个算法	来表示两个人之间的关系。

## 检测重复元素

给定一个非常大的URL集合，比如：10亿。设计一个算法来检测重复的URL。

## 实现表的合并

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190927210719.png)

2）将一个表存入到hash表中。然后遍历另一个表，

3）将两个表都做一个hash运算，有相同的hash的student_id放到同一机器上，然后利用2）的方法对每台机器进行合并

# 动态规划和递归

相同点：都能分解成若干子问题

不同点：DP存储子问题结果

动态规划避免子问题的重复计算，通过数组来记录每个子问题的解，达到空间换时间。

动态规划四要素：

- 状态：存储小规模问题的结果
- 方程：从小状态到大状态的转移
- 初始化：最极限的小状态
- 答案：最大的那个状态

# 记忆化搜索

在递归过程中，通过一个hashtable记录中间的计算结果，比如input作为key，output作为value。

```c++
T func(N node, HastTable<N,T>& cache)
{
    if (cache.contains(node))
        return cache.get(node);
    ... 
    T sub_res = func(next_node, cache);\
    ...
        //当前子问题的解，依赖于更小的子问题
    T res = G(sub_res...);
    cache.set(node, ers);
    return res;
}

```

# 算法策略比较

- 分而治之：归并排序，快速排序
- 动态规划：记录子问题的结果，避免不重复计算子问题
- 贪婪算法：记录走向全局最优解的局部解，当计算后续解是可以考虑前面的局部解，比如迪杰斯特拉算法
- 回溯：穷举，树的DFS

fibonacci数列实现：

- 递归

- 动态规划
- 矩阵乘法：[[1,1],[1,0]]相乘
- c++模板

```c++
struct Fib
{
    enum{
    	val = Fib<N-1>::val + Fib<N-2>::val  
    };
}

template<>
struct Fib<0>
{
	enum{
		val = 0
	};
}

template<>
struct Fib<1>
{
	enum{
		val = 1;
	};
}
```

## 爬楼梯

```c++
int climibStairs(int n)
{
    if (n == 1)
        return 1;
    if (n == 2)
        return 2;
    int dp[n+1] = {0};
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i <= n; ++i)
        dp[i] =  dp[i-1] + dp[i-2];
    return dp[n];
}
```

## 第n个素数

```c++
int GetNthPrime(int n)
{
    list<int> primes(1,2);
    int number = 3;
    while(primes.size() <= n)
    {
        bool isPrime = true;
        for (auto ite = primes.begin(); ite != primes.end() && (*ite)*(*ite) <= number; ++ite)
            if (number % *ite == 0)
                isPrime = false;
        if (isPrime)
            primes.push_back(number);
        number += 2;   
    }
    return *(primes.rbegin());
}
```

## 分割单词

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20190930133603.png)

```c++
bool wordBreak(string s, unordered_set<string>& dict)
{
    int begin = 0, end = 0;
    string word;
    bool words[s.size()+1] = {0};
    words[0] = true;
    
    for (int i = 1; i < s.size() + 1; ++i)
    {
        words[i] = false;
        for (end = 0; end < s.size(); ++end)
            for (begin = 0; begin < end; ++begin)
                if (words[begin] && dict.find(s.substr(begin, end-begin+1))!= dict.end())
                {
                    words[end+1] = true;
                    break;
                }
    }
    return words[s.size()];
}
```

## 回文切割(Palindrome Partition)

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191002152730.png)

## 唯一的路径

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191002153607.png)

```c++
int uniquePathsBackTrack(int m, int n)
{
    if (m == 1 || n == 1)
        return uniquePath(m-1, n) + uniquePath(m, n-1);
}

int uniquePath(int m, int n)
{
   	vector<vector<int> > table(m, vector<int>(n, 1));
    for (int i = 1; i < m; ++i)
        for (int j = 1; j < n; ++j)
            table[i][j] = table[i][j-1] + table[i-1][j];
    return table[m-1][n-1];
}
```

节省空间通过一个一维数组实现：

```c++
int uniquePaths2(int m, int n)
{
    vector<int> table(n, 1);
    for (int i = 1; i < m; i++)
        for (int j = 1; j < n; j++)
            table[j] += table[j-1];
    return table[n-1];
}
```

## 唯一路径Ⅱ

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191002154655.png)

```c++
int uniquePathsWithObstacles(vector<vector<int> > & obstacleGrid)
{
    if (obstacleGrid.empty() || obstacleGrid[0].empty())
        return 0;
    
    int m = obstacleGrid.size();
    int n = obstacleGrid[0].size();
    
    int dp[m][n];
    dp[0][0] = (obstacleGrid[0][0] == 1) ? 0 : 1;
    
    for (int i = 1; i < m; ++i)
        dp[i][0] = (dp[i-1][0] == 1 && obstacleGrid[i][0] == 0) ? 1 : 0;
    
    for (int j = 1; j < n; ++i)
        dp[0][j] = (dp[0][j-1] == 1 && obstacleGrid[0][j] == 0) ? 1 : 0;
    
    for (int i = 1; i < m; ++i)
        for (int j = 1; j < n; ++j)
            if (obstacleGrid[i][j] == 1)
                dp[i][j] = 0;
    		else
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
    return dp[m-1][n-1];
}
```

## 最小的路径和

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191002155621.png)

```c++
int minPathsum(vector<vector<int> > &grid)
{
    if (grid.empty() || grid[0].empty())
        return 0;
    
    int row = grid.size();
    int col = grid[0].size();
    
    int dp[row][col];
    dp[0][0] = grid[0][0];
    for (int i = 1; i < row; ++i)
        dp[i][0] = dp[i-1][0] + grid[i][0];
    for (int j = 1; j < col; ++j)
        dp[0][j] = dp[0][j-1] + grid[j][0];
    
    for (int i = 1; i < row; ++i)
        for (int j = 1; j < col; ++i)
            dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j];
    return dp[row-1][col-1];
}
```

## 跳跃游戏

![1570003668165](C:\Users\zxp\AppData\Roaming\Typora\typora-user-images\1570003668165.png)

```c++
bool canJump(int A[], int n)
{
    if (n == 0)
        return true;
    int v = A[0];
    for (int i = 1; i < n; ++i)
    {
        v--;
        if ( v < 0 )
            return false;
        if (v < A[i]);
        	v = A[i];
    }
    return true;
}
```

## 三角形最小值

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191002161222.png)

```c++
int minmumTotal(vector<vector<int> > &triangle)
{
    int row = triangle.size();
    if (row == 0)
        return 0;
    
    vector<int> total(row, INT_MAX);
    total[0] = triangle[0][0];
    int minTotal = INT_MAX:
    for (int i = 1; i < row; ++i)
        for (int j = i; j >= 0; --j)
        {
            if (j == 0)
                total[j] = total[j] + triangle[i][j];
            else
                total[j] = min(total[j-1], total[j]) + triangle[i][j];
        }
    for (int i = 0; i < row; i++)
        minTotal = min(minTotal, total[i]);
    return minTotal;
}
```

## 唯一二叉搜索树

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191002162550.png)

```c++
int numTrees(int n)
{
    vector<int> dp(n+1, 0);
    
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; ++i)
        for (int j = 0; j < i; j++)
            dp[i] += dp[j] * dp[i-j-1];
    return dp[n];
 }
```

## 硬币置换

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191002212043.png)

```c++
int countWays(vector<int>& S, int m, int n)
{
    vector<int> table(n+1, 0);
    table[0] = 1;
    for (int i = 1; i <= n; ++i)
        for (int j = 0; j < m; ++j)
            table[i] += (i - S[j] >= 0) ? table[i-S[j]] : 0;
    return table[n];
}
```

使用最少的硬币进行置换：

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191002212847.png)

```c++
int countWays(vector<int>& S, int m, int n)
{
    vector<int> table(n+1, 0);
    table[0] = 0;
    for (int i = 1; i <= n; ++i)
        for (int j = 0; j < m; ++j)
            if (i >= S[j] && table[i] > table[i-S[j]])
            	table[i] = table[i-S[j]] + 1;
    return table[n];
}
```

# 最长子序列问题

## 最长子序列

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191003085016.png)

```c++
int longestIncreasingSubsequence(int arr[], int n){
    vector<int> maxLength(n, 1);
    int global_max = 0;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < i; ++j)
            if (arr[i] > arr[j] && maxLength[j] + 1 > maxLength[i])
                maxLenght[i] = maxLength[j] + 1;
    for (int i = 0; i < n; ++i)
        if (global_max < maxLength[i])
            global_max = maxLength[i];
    return global_max;
}
```

## 加油站

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191003085706.png)

```c++
int canCompleteCircuit(vector<int>& gas, vector<int>& cost)
{
    int size = gas.size();
    int subSum = 0, sum = 0;
    int array[size];
    int index = 0;
    for (int  i = 0 ; i < size; ++i)
    {
        array[i] = gas[i] - cost[i];
        sum += array[i];
    }
    if (sum < 0)
        return -1;
    for (int i = 0; i < size; ++i)
    {
        subSum += array[i];
        if (subSum < 0)
        {
            subSum = 0;
            index = i+1;
        }
    }
    return index;
}
```

## 最长公共子序列

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191003090329.png)

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191003090356.png)

```c++
int lcs(string str1, string str2)
{
    vector<vector<int> > lenght(str.size()+1, vector<int>(str.size()+1));
    for (int i= 0; i < str1.size(); ++i)
        for (int j = 0; j < str2.size(); ++j)
        {
            if (i == 0 || j == 0)
                lenght[i][j] = 0;
            else if (str[i-1] ==  str2[j-1])
                length[i][j] = length[i-1][j-1] + 1;
            else if 
                length[i][j] = max(length[i-1][j], length[i][j-1]);
        }
    return length[str1.size()][str2.size()];
}
```

## 除本身之外的乘积

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191003091645.png)

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191003091810.png)

````c++
void replaceWithProducts(int elements[], int n)
{
    int a[n];
    int products_below[n];
    int p = 1;
    for (int i = 0 ; i < n; ++i)
    {
        products_below[i] = p;
        p *= elements[i];
    }
    
    int products_above[n];
    p = 1;
    for (int i = n-1; i >= 0; --i)
    {
        products_above[i] = p;
        p *= elements[i];
    }
    
    int products[n];
    for (int i = 0; i < n; ++i)
        products[i] = products_below[i] * products_above[i];
}
//第二种方法
void replaceWithProducts(int elements[], int n)
{
    int product = 1;
    vector<int> table(n,1);
    for (int i = 0; i < n; ++i)
    {
        table[i] = product;
        product *= elements[i];
    }
    
    product = 1;
    vector<int> res(n,1);
    for (int i = n-1; i >= 0; --i)
    {
        res[i] = table[i] * product;
        prodct *= elements[i];
    }
}
````

## 盛水

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191003092700.png)

```c++
int trap(int A[], int n)
{
    if (n <= 0) return 0;
    int left_max = 0, right_max = 0, wate = 0;
    vector<int> dp(n, 0);
    for (int i = 0; i < n; ++i)
    {
        dp[i] = left_max;
        if (A[i] > left_max)
            left_max = A[i];
    }
    
    for (int i = n-1; i >= 0; --i)
    {
        if (min(right_max, dp[i]) > A[i])
        	water += min(right_max, dp[i]) - A[i];
        if (A[i] > right_max)
            right_max = A[i];
    }
}
```

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191003093259.png) 

## Tallest stack of boxes

Given a set of boxes, each one has a square bottom and height of 1. Please write a function to return the tallest stack of these boxes. The constraint is that a box can be put on top only when its square bottom is restrictively smaller.

```c++
vector<Box> createStackDP( Box boxes[], const int num, Box bottom, unordered_map< Box, vector<Box> >& stackCache) {
    vector<Box> max_stack;
    int max_height = 0;
    vector<Box> new_stack;
  
    // memorization
    if( stackCache.count( bottom ) > 0 )
        return stackCache[ bottom ];
    else {
        for( int i = 0; i < num; i++ ) {
            if( Box[i].canBeAbove( bottom ) ) {
                // solve subproblem
                new_stack = createStackDP( boxes, num, Box[i], stackCache );
            }
            if( new_stack.size() > max_height ) {
                max_height = new_stack.size();
                max_stack = new_stack;
            }
        }
    }
  
    max_stack.insert( max_stack.begin(), bottom );
    stackCache[ bottom ] = max_stack;
    return max_stack;
}
```



## Word Break Ⅱ

Given a string and a dictionary of words, please write a function to add space into the string, such that the string can be completely segmented into several words, where every word appears in the given dictionary.

**代码实现**

```c++
vector<string> wordBreak(string s, unordered_set<string> &dict, unordered_map<string,vector<string> >& cache) {
    // memorization
    if(cache.count(s))
        return cache[s];
        
    vector<string> vs;
        
    if(s.empty()) {
        vs.push_back(string());
        return vs;
    }
        
    for(int len = 1; len <= s.size(); ++len ) {
        string prefix = s.substr(0,len);
        if(dict.count(prefix) > 0) {          
            string suffix = s.substr(len);

            // solve subproblem
            vector<string> segments = wordBreak(suffix,dict,cache);          
            for(int i = 0; i < segments.size(); ++i) {
                if(segments[i].empty()) 
                    vs.push_back(prefix);
                else 
                    vs.push_back(prefix + " " + segments[i]);
            }
        }
    }
        
    cache[s] = vs;
    return vs;
}
```

