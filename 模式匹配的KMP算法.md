---
title: 模式匹配的KMP算法
date: 2018-08-22 22:28:50
tags: 算法
categories: "算法"
mathjax: true

---



简单模式匹配算法的效率不高，原因在于匹配过程中的回溯。KMP匹配算法的时间复杂度是O(m+n)，优于简单算法，原因在于KMP算法到达失配点，串S不需要回溯，串P也不一定要回溯到第1个字符的位置。<!--more-->

模式匹配：设有两个串S和P,称在串中S中找串P的过程为模式匹配。S为主串，P为字串。

KMP算法的关键是$j$回溯到什么位置，实现KMP算法的关键是求出模式串$P$的每个字符的最大$k$值，$k$是失配时$j$需要向前回溯的最少位置。下一趟比较就可以从$S[i]$和$P[k]$开始。设主串为$S="s_0s_1{\cdots}s_{n-1}"$，模式串为$P="p_0p_1{\cdots}p_{m-1}"$，并设在$s_i \neq p_j$处失配。考察P串，如果发现：

$$p_0p_1{\cdots}p_{k-1} = p_{j-k}p_{j-k+1}{\cdots}p_{j-1}\tag{1-1} $$

是失配点前的串$p_0p_1{\cdots}p_{j-1}$中“最长的相同的前缀子串和后缀子串”，其中，$p_0p_1{\cdots}p_{k-1}$是$p_0p_1{\cdots}p_{j-1}$的前缀子串，$p_{j-k}p_{j-k+1}{\cdots}p_{j-1}$是$p_0p_1{\cdots}p_{j-1}$的后缀子串。那么，由于匹配在$s_i \neq p_j$处失败，所以必有：

$$p_{j-k}{\cdots}p_{j-2}p_{j-1} = s_{i-k}{\cdots}p_{i-2}p_{i-1}\tag{1-2} $$  

综合式（1-1）和式（1-2）,可得式（1-3）：

$$p_0{\cdots}p_{k-2}p_{k-1} = s_{i-k}{\cdots}s_{i-2}s_{i-1}\tag{1-3} $$   


式（1-3）说明，下一趟匹配过程从$s_i$和$p_k$开始，即将模式串中$k$位置的字符和主串中$i$位置的字符对齐后开始下一趟比较。

### 1.失败函数f

设长度为$m$的模式串$P=“p_0p_1{\cdots}p_{m-1}”$，$k$为相同的前、后缀子串长，失败函数定义为：

$$f(j) =\begin{cases} 
-1 & j=0\\ |  
\max  \left (k | 0<k<j 且 p_0p_1{\cdots}p_{k-1} = p_{j-k}p_{j-k+1}{\cdots}p_{j-1}\right )\\ | 
0 & other\\
\end{cases}\tag{1-4}
$$


从式（1-4）可以看出，失败函数$f(j)$被定义为相同的前、后缀子串长的最大值，其含义为：当匹配在$s_i \neq p_j$处失败，$j$应该回溯的的位置$f(j)$。$f(j) \geq or \ge 0$表示下趟匹配过程从$s_i$和$p_{f(j)}$开始；$f(j)=-1$表示从下趟匹配过程从$s_{i+1}$和$p_0$开始。

|j|0|1|2|3|4|5|6|7|8|9|10|
| --- |
|P|a|b|c|a|b|c|a|b|b|a|c|
|$f(j)$|-1|0|0|0|1|2|3|4|5|0|1|

$f(j)$的取决于模式串$P$自身的特性。一种特殊的情况，$P$中没有相同的字符出现，或头尾相同，其余不同，则除了$f(0)=-1$外，其他得$f(j)$均为0。也就是说，当到达失配点，$P$均回到第1个字符a_0开始下一趟匹配。

### 2. KMP算法的C++程序

设串P的f值已求得

	int FindKMP(int i, String &P)
	{
		if (i<0 || i>n-1){
			cout << "Out of bounds!" <<endl;
			return -1;
		}
	
		int j=0, m=P.n;
		while(i<n && j<m)
		{
			if( j==-1 || str[i] == P.str[j])
			{
				i++; j++;
			}
			else j=P.f[j];
		return ( (j==m)?i-m:-1)
		}
	}



