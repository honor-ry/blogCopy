---
title: 区块链(BlockChain)
date: 2019-10-27 11:44:14
tags: 区块链
mathjax: true
---

区块链技术分析。学习资料： http://zhenxiao.com/blockchain/ <!--more-->

# 区块链

区块链就是一个链表，不过链表的指针不是地址，而是哈希值。

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191027143344.png)

区块链中有许多的区块组成，每个区块有一个哈希值，是当前区块头部的哈希。而它的下一个区块有一个指向该区块。

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191027143210.png)

一个区块中包括头部（Block header）和交易信息（Block body）。

区块头部包括：

- nonce
- Merkle root hash
- Timestamp
- previous header hash
- hash 

Merkle root hash是由区块中所有交易所组成一个Merkle tree的根节点：

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191027143741.png)

区块链中用到的两种数据结构：

- Merkle tree
- Block chain

# 比特币

比特币中用到的密码学:

- 哈希：抗碰撞(collision resistance)、单向(hiding)、puzzle friendly（hash值是不可预测，必须通过计算，如果要hash值在某个范围内，必须一次一次尝试）
- 签名：私钥签名、公钥解密（每笔交易都要用私钥签名）

比特币系统对消息取hash，然后对hash值签名。

系统中节点分为两类：

- 全节点
- 轻节点

**比特币总量：**

每4年可以一个挖出一个区块所奖励的比特币减半，最开始是一个区块奖励50BCT。

系统中总共的比特币数量为：2100万
$$
21w\times50+21w\times25+21w\times12.5+... \\
=21w\times50\times(1+\frac{1}{2}+\frac{1}{4}+...)\\
=21w\times50\times2\\
=2100w
$$
防止double spending:

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191027135651.png)

需要等待6个确认（缺省等待6个confirmation），才能保证前面的交易是不可篡改的。平均出块时间是10分钟，所以需要等待1个小时。不能及时支付。

## 网络

BitCoin工作在应用层，网络层是一个P2P Overlay网络，网络中所有节点是对等的。

需要加入网络，首先需要知道一个seed种子节点，它会高速你网络中的其他节点，采用TCP通信，有利于穿透防火墙。

离开网络，不用做任何操作，过一段时间，其他节点没有收到你得消息，就会将你删掉。

**设计原则**：简单、鲁棒，而不是高效

每个节点维护一个邻接节点的集合。网络中消息传播，采用flooding的方式，节点第一听到消息时，并传播给邻接节点，并记录已经收到过该消息，下次收到该消息时不要再转发给邻接节点。

邻接节点的选取是随机的，与距离无关，增强鲁棒性，牺牲了效率。

 ## 挖矿难度

怎么调整挖矿难度？

通过寻找nonce值，使得：
$$
H(block header) \leq target
$$
target越小，挖矿难度越大。调整挖矿难度，就是调整输出空间在目标空间中的比例。

比特币用的hash算法是SHA-256。整个输出空间是$2^{256}$。调整输出空间在整个输出空间的比例，简单来说，是调整hash值签名0的个数，比如说hash之前有70个0才是合法的区块。

挖矿难度与目标阈值target成反比，挖矿难度为1对应的目标阈值$difficulty\_1\_target$，则当前挖矿难度可以表示为：
$$
difficulty =\frac{difficulty\_1\_target}{target}
$$
系统中整个算法越来越强，如果不调整挖矿难度，则出块的时间会越来越短。

出块时间太短带来的问题：

- 网络延迟过大，分叉情形更容易出现，变成常态，甚至出现n分叉（n=2,3,4...），分叉越多对于系统达成公示没有好处

每2106区块更新一次阈值。阈值调整的时间间隔：
$$
\frac{2016\times10}{60\times24}=14days
$$
target阈值迭代更新的方法：
$$
target=target\times\frac{actual\space time}{expected \space time}
$$

$$
expected\space time = 2106\times10 min \\
$$

actual time是最后一个2016区块被挖出来所需要的时间。

如果actual time大于两个星期，表明需要降低挖矿的难度，就增大target；

如果actual time小于两个星期，表明需要增大挖矿的难度，就降低target。

注意，target的值一次最大增大4倍。同样最小降低4倍。

每个节点必须更新target，因为Block header里面有一个nBits存储了target的编码。如果不更新target，就无法通过区块合法性验证。

## 挖矿

比特币中有两种节点：

- 全节点
  - 一直在线
  - 在本地硬盘上维护完整的区块链信息
  - 在内存里维护UTXO集合，以便快速检验交易的正确性
  - 监听比特币网络上的交易信息，验证每个交易的合法性
  - 决定哪些交易会被打包到区块里
  - 监听别人的矿工挖出来的区块，验证其合法性
  - 挖矿
    - 决定沿着哪条链挖下去？
    - 当出现等长的分叉的时候，选择哪一个分叉？
- 轻节点
  - 不是一直在线
  - 不用保存整个区块链，只要保存每个区块的块头
  - 不用保存全局交易，只保存与自己相关的交易
  - 无法检验大多数交易的合法性，只能检验与自己相关的那些交易的合法性
  - 无法检测网上发布的区块的正确性
  - 可以验证挖矿的难度
  - 只能检测哪个是最长链，不知道哪个是最长合法链

比特币网络中大部分节点是轻节点。

**挖矿是无记忆性的（memory less）**。前面挖了多长时间对后面没有影响。

第一代挖矿设备：CPU

第二代挖矿设备：GPU，并行

第三代挖矿设备：ASIC芯片（Application Specific Integrated Circuit）:专门设计用来挖矿

比特币的安全：

- 密码学：签名、哈希值
- 共识机制

## 矿池

把矿工组织起来，作为一个整体，一个全节点驱动很多矿工。

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191028131647.png)

矿工只负责计算哈希值，其他职责由pool manager来负责，负责网络上的交易，将交易打包成候选区块等等，全节点的职责由pool manager实现。

同时，矿池解决了收益不稳定的问题。单个矿工的收益是不稳定的。

矿主将哈希值计算任务分配给每个矿工，矿工负责计算，将结果返回给矿主。最后分红根据哈希值计算的贡献来分配。

矿池使得50%攻击难度降低。

Boycott攻击：出现某笔交易，立即开出一个分叉。

## 比特币脚本

基于栈的语言

**交易结构：**

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191028133838.png)

vin是输入，vout是输出。

locktime为1，需要等待某个数量的确认才能确认。

**交易的输入：**

![1572241193325](C:\Users\zxp\AppData\Roaming\Typora\typora-user-images\1572241193325.png)

txid：表示交易的币来自之前那个交易的第一个输出。

vout: 表示第几个输出。

scriptSig: 输入脚本

一个交易可以有多个输入。

交易的输出：

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191028134242.png)

value： 交易的比特币数量。

scriptPubKye是输出脚本。

![](https://raw.githubusercontent.com/zxpgo/images/master/img/20191028135049.png)

## 比特币匿名性

比特币地址就是公钥的哈希值。

匿名性分为：

- 网络层：采用洋葱路由TOR，你别人无法追踪到你的IP地址
- 应用层：coin mixing

## 零知识证明

**零知识证明**是指一方（证明者）向另一方（验证者）证明一个陈述是正确的，而无需透露除了该陈述是正确外的任何信息。

证明某一个比特币账户是我的。说明我拥有该账户的私钥。但是私钥不能告诉别人。我要证明我要私钥但不能告诉你。可以用私钥进行签名，然后对方可以用公钥进行验证。我是证明着，对方是验证者，陈述是我的私钥。**这个是不是零知识证明是有争议的**，因为泄漏了一个用签名。

**同态隐藏：**

- 性质一：如果$x,y$不同，那么它们的加密函数值$E(x)$和$E(y)$也不相同
- 性质二：给定$E(x)$的值，很难反推$x$的值
- 性质三：给定$E(x)$和$E(y)$的值，我们可以很容易地计算出某些关于$x,y$的加密函数值：
  - 同态加法：通过$E(x)$和$E(y)$计算出$E(x+y)$的值
  - 同态乘法：通过$E(x)$和$E(y)$计算出$E(xy)$的值
  - 扩展到多项式

例子：Alice想要向Bob证明她知道一组数$x$和$y$使得$x+y=7$，同时不然Bob知道$x$和$y$的具体值。

简单版本：

- Alice把$E(x)$和$E(y)$的数值发送给Bob
- Bob通过收到的$E(x)$和$E(y)$计算出$E(x+y)$的值（利用了性质三）
- Bob同时计算$E(7)$的值，如果$E(x+y)=E(7)$，那么验证通过，否则验证失败（利用了性质一和二）

通过蛮力破解$E(x)$和$E(y)$。

**盲签方法：**

- 用户A提供SerialNum，银行在不知道SerialNum的情况下返回签名Token，减少A的存款
- 用户A把SerialNum和Token交给B完成交易
- 用户B拿到SerialNum和Token给银行验证，银行验证通过，增加B的存款
- 银行无法把A和B联系起来
- 中心化

为了匿名信设计了**零币和零钞**。

- 零币和零钞在协议层就融合了匿名化处理，其匿名属性来自密码学保证。
- 零币(zerocoin)系统中存在基础比和零币，通过基础币和零币的来回转换，消除旧地址和新地址的关联性，其原理类似于混币服务。
- 零钞(zerocash)系统使用zk-SNARKs协议，不依赖一种基础币，区块链中只记录交易的存在性和矿工用来验证系统正常运行所需要关键属性的证明。区块链上既不显示交易地址也不显示交易金额，所有交易通过零知识验证的方式进行。

零币和零钞的应用不太广，需要这种强匿名信的用户不太多。在数学上是匿名的，但是不是100%的匿名，因为没有解决与实体发生交互的时候，仍然会暴露身份。